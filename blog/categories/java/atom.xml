<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 码匠笔记]]></title>
  <link href="http://www.majiang.life/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://www.majiang.life/"/>
  <updated>2018-02-23T11:46:09+08:00</updated>
  <id>http://www.majiang.life/</id>
  <author>
    <name><![CDATA[麻酱]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[细说 Java hashCode]]></title>
    <link href="http://www.majiang.life/blog/deep-dive-on-java-hashcode/"/>
    <updated>2017-12-24T01:04:24+08:00</updated>
    <id>http://www.majiang.life/blog/deep-dive-on-java-hashcode</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>写过 <code>Java</code> 程序的同学一定都知道 <code>hashCode</code> 方法，它是 <code>Object</code> 对象的一个 <code>native</code> 方法。无论是我们平常使用的 <code>HashMap</code> 还是重写 <code>equals</code> 方法的时候，都会接触到 <code>hashCode</code> 方法，那么它究竟是怎么生成的，又有什么作用呢？笔者带着这个疑问开始探寻。</p>

<!-- more -->


<h2>hashCode 方法的定义</h2>

<p>在 <a href="https://docs.oracle.com/javase/7/docs/api/"><code>jdk api</code></a> 中 关于 <code>hashCode</code> 有如下说明：</p>

<pre><code class="sh">Returns a hash code value for the object. 
This method is supported for the benefit of hash tables such as those provided by HashMap.
The general contract of hashCode is:

Whenever it is invoked on the same object more than once during an execution of a Java application, 
the hashCode method must consistently return the same integer, 
provided no information used in equals comparisons on the object is modified. 
This integer need not remain consistent from one execution of an application to another execution of the same application.
If two objects are equal according to the equals(Object) method, 
then calling the hashCode method on each of the two objects must produce the same integer result.
It is not required that if two objects are unequal according to the equals(java.lang.Object) method, 
then calling the hashCode method on each of the two objects must produce distinct integer results. 
However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.
As much as is reasonably practical, 
the hashCode method defined by class Object does return distinct integers for distinct objects. 
(This is typically implemented by converting the internal address of the object into an integer, 
    but this implementation technique is not required by the JavaTM programming language.)
</code></pre>

<p>其大致意思如下</p>

<pre><code class="sh">只要在Java应用程序的执行过程中多次调用同一个对象，
hashCode方法必须始终返回相同的整数，
前提是在对象的equals比较中没有使用的信息被修改。  
从应用程序的一次执行到同一应用程序的另一次执行，此整数不必保持一致。  

如果两个对象按照equals（Object）方法相等，
那么在两个对象的每一个上调用hashCode方法必须产生相同的整数结果。  
如果两个对象根据equals（java.lang.Object）方法不相等，
则不要求对两个对象中的每个对象调用hashCode方法都必须产生不同的整数结果。  
但是，程序员应该知道，为不相等的对象生成不同的整数结果可以提高散列表的性能。  

尽可能多地合理实用，由类Object定义的hashCode方法确实为不同的对象返回不同的整数。  
这通常通过将对象的内部地址转换为整数来实现，但JavaTM编程语言不需要此实现技术。 
</code></pre>

<p>所以由上可以得到两条有用的信息，同一个对象 <code>hashcode</code> 的值在一次运行中一定相等，并且不同对象的 <code>hashcode</code> 一定不同，但是他还备注通常使用内部地址转换，但是 <code>JAVA</code> 不是使用这种方式实现的，那么怎么实现的呢？</p>

<h2>hashCode 实现原理</h2>

<h3>hashcode 源码</h3>

<p><code>OpenJDK</code> 的源码可以直接查看，所以我们就选择查看一下其源码一看究竟。<br/>
我们可以看到<code>src/share/vm/prims/jvm.h</code>和<code>src/share/vm/prims/jvm.cpp</code>两个文件中有关于 <code>hashcode</code> 的说明如下：
<code>
   JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))
   JVMWrapper("JVM_IHashCode");
   // as implemented in the classic virtual machine; return 0 if object is NULL
   return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;
 JVM_END
</code>
我们继续进入<code>FashHashCode</code>里面查看，其位于<code>src/share/vm/runtime/synchronizer.cpp</code>文件，相对代码比较多，我们只摘取关键部分：
{% codeblock lang:cpp %}
{% raw %}
  // Inflate the monitor to set hash code
  monitor = ObjectSynchronizer::inflate(Self, obj);
  // Load displaced header and check it has hash code
  mark = monitor->header();
  assert (mark->is_neutral(), &ldquo;invariant&rdquo;) ;
  hash = mark->hash();
  if (hash == 0) {
    hash = get_next_hash(Self, obj);
    temp = mark->copy_set_hash(hash); // merge hash code into header
    assert (temp->is_neutral(), &ldquo;invariant&rdquo;) ;
    test = (markOop) Atomic::cmpxchg_ptr(temp, monitor, mark);
    if (test != mark) {
      // The only update to the header in the monitor (outside GC)
      // is install the hash code. If someone add new usage of
      // displaced header, please update this code
      hash = test->hash();
      assert (test->is_neutral(), &ldquo;invariant&rdquo;) ;
      assert (hash != 0, &ldquo;Trivial unexpected object/monitor header usage.&rdquo;);
    }
  }
  // We finally get the hash
  return hash;
{% endraw %}
{% endcodeblock %}
<code>monitor</code> 相关代码我们先略过不理，通过 <code>if</code> 语句我们可以看出，当 <code>hash</code>为0时候需要调用 <code>get_next_hash</code> 生成一个新的 <code>hash</code>，那么我们便可以继续前行。
{% codeblock lang:cpp %}
{% raw %}
static inline intptr_t get_next_hash(Thread * Self, oop obj) {
  intptr_t value = 0 ;
  if (hashCode == 0) {
     // This form uses an unguarded global Park-Miller RNG,
     // so it&rsquo;s possible for two threads to race and generate the same RNG.
     // On MP system we&rsquo;ll have lots of RW access to a global, so the
     // mechanism induces lots of coherency traffic.
     value = os::random() ;
  } else
  if (hashCode == 1) {
     // This variation has the property of being stable (idempotent)
     // between STW operations.  This can be useful in some of the 1-0
     // synchronization schemes.
     intptr_t addrBits = cast_from_oop<intptr_t>(obj) >> 3 ;
     value = addrBits ^ (addrBits >> 5) ^ GVars.stwRandom ;
  } else
  if (hashCode == 2) {
     value = 1 ;            // for sensitivity testing
  } else
  if (hashCode == 3) {
     value = ++GVars.hcSequence ;
  } else
  if (hashCode == 4) {
     value = cast_from_oop<intptr_t>(obj) ;
  } else {
     // Marsaglia&rsquo;s xor-shift scheme with thread-specific state
     // This is probably the best overall implementation &ndash; we&rsquo;ll
     // likely make this the default in future releases.
     unsigned t = Self-><em>hashStateX ;
     t ^= (t &lt;&lt; 11) ;
     Self-></em>hashStateX = Self-><em>hashStateY ;
     Self-></em>hashStateY = Self-><em>hashStateZ ;
     Self-></em>hashStateZ = Self-><em>hashStateW ;
     unsigned v = Self-></em>hashStateW ;
     v = (v ^ (v >> 19)) ^ (t ^ (t >> 8)) ;
     Self->_hashStateW = v ;
     value = v ;
  }
  value &amp;= markOopDesc::hash_mask;
  if (value == 0) value = 0xBAD ;
  assert (value != markOopDesc::no_hash, &ldquo;invariant&rdquo;) ;
  TEVENT (hashCode: GENERATE) ;
  return value;
}{% endraw %}
{% endcodeblock %}
通过上述代码我们看到，其实 <code>hashCode</code> 的生成有6中方式<br/>
1. 随机数<br/>
2. 对象的内存地址的函数<br/>
3. 固定值，这个只是为了进行灵敏度测试<br/>
4. 递增序列<br/>
5. int类型的该对象的内存地址 <br/>
6. 结合当前线程和xorshift生成</p>

<p>通过 <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/globals.hpp#l1127">globals.hpp</a> 我们可以发现，JDK8 默认为5，也就是最后一种。<br/>
<code>product(intx, hashCode, 5, "(Unstable) select hashCode generation algorithm")</code>  <br/>
当然，OpenJDK6，7中用的都是第一种方案，那么问题又来了，既然都是随机数，那么怎么确保每次都一样的呢？</p>

<h3>对象头</h3>

<p>这里就需要引入一个<code>对象头</code>的概念，每次对象生成以后，都需要找一个地方存储一下这个对象的hashCode和锁信息，这就是<code>对象头</code>，英文称之为 <code>Mark Word</code>。这样一来我们就明白了，每次生成对象以后都会把它的<code>hashCode</code>存起来，这样无论对象怎么在新生代，老年代之间<code>游走</code>都不会改变其<code>hashCode</code>的值，然而事实并没有那么简单。</p>

<h3>偏向锁</h3>

<p>这时候我们翻回来看刚才略过的内容，<code>ObjectSynchronizer::FastHashCode()</code>里面的其他逻辑。
{% codeblock lang:cpp %}
{% raw %}
if (UseBiasedLocking) {
    // NOTE: many places throughout the JVM do not expect a safepoint
    // to be taken here, in particular most operations on perm gen
    // objects. However, we only ever bias Java instances and all of
    // the call sites of identity_hash that might revoke biases have
    // been checked to make sure they can handle a safepoint. The
    // added check of the bias pattern is to avoid useless calls to
    // thread-local storage.
    if (obj->mark()->has_bias_pattern()) {
      // Box and unbox the raw reference just in case we cause a STW safepoint.
      Handle hobj (Self, obj) ;
      // Relaxing assertion for bug 6320749.
      assert (Universe::verify_in_progress() ||
              !SafepointSynchronize::is_at_safepoint(),
             &ldquo;biases should not be seen by VM thread here&rdquo;);
      BiasedLocking::revoke_and_rebias(hobj, false, JavaThread::current());
      obj = hobj() ;
      assert(!obj->mark()->has_bias_pattern(), &ldquo;biases should be revoked by now&rdquo;);
    }
  }
{% endraw %}
{% endcodeblock %}
由上述代码我们可以得知，当前对象处于<code>偏向锁</code>时，会清除<code>偏向锁</code>通过从<code>锁</code>上面取回<code>Mark Word</code> 信息。为什么提到取回呢？之前消失了吗？是的，现在就需要解释一下<code>偏向锁</code>了。<br/>
<code>Hotspot</code> 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入
了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 <code>ID</code>，以后该线程在进入和退出同步块时不需要花费 <code>CAS</code> 操作来加锁和解锁，而只需简单的测试一下对象头的 <code>Mark Word</code> 里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下 <code>Mark Word</code> 中偏向锁的标识是否设置成 1（表示当前是偏向锁），如果没有设置，则使用 <code>CAS</code> 竞争锁，如果设置了，则尝试使用 <code>CAS</code> 将对象头的偏向锁指向当前线程。所以我们便知道为什么有<code>取回</code>这个概念了。然而代码带没有结束。</p>

<h3>轻量级锁</h3>

<p>轻量级锁相对比较简单，<code>JVM</code>会在当前的线程栈桢中创建用于存放锁的空间，同时将对象头中的<code>Mark Word</code>复制到锁记录中，也称作 <code>Displaced Mark Word</code>。比较复杂的是<code>重量级</code>锁。</p>

<h3>重量级锁</h3>

<p>这个时候如果多个线程来竞争资源，就会发生<code>锁膨胀</code>，这样因为需要保存竞争资源需要<code>wait</code>的线程和相关信息，就引入了<code>monitor</code>的概念。于是这时候就把<code>Mark Word</code>存放到了<code>Monitor</code>里面，当然<code>Monitor</code>不仅仅用于存储对象的<code>Mark Word</code>，具体的作用就不是本文的重点了。</p>

<h2>hashCode 的用途</h2>

<p><code>hashCode</code> 的唯一性决定了他可以用来生成<code>HashMap</code>的key，同时也能判断对象是否为同一个对象。另外我们再重写他的时候要多加注意，因为<code>JVM</code>会根据它做一些性能优化。</p>

<h2>总结</h2>

<p>此文为笔者学习 <code>hashCode</code> 的笔记，如有问题欢迎指正。</p>

<h2>参考文献</h2>

<p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm">OpenJDK 源码</a><br/>
<a href="https://docs.oracle.com/javase/7/docs/api/">Oracle JDK Docs</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从 Spring 集成 Mybatis 到 浅析Java动态代理]]></title>
    <link href="http://www.majiang.life/blog/spring-mybatis-and-dynamic-proxy/"/>
    <updated>2017-10-15T21:10:30+08:00</updated>
    <id>http://www.majiang.life/blog/spring-mybatis-and-dynamic-proxy</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>因为 <code>MyBatis</code> 的易上手性和可控性，使得它成为了<code>ORM</code>框架中的首选。近日新起了一个项目，所以重新搭建了一下 <code>Spring-mybatis</code>, 下面是搭建笔记和从<code>Spring-mybatis</code>源码分析其如何使用<code>Java动态代理</code>，希望对大家有帮助。</p>

<!-- more -->


<h2>Spring 集成 Mybatis</h2>

<p><code>Spring</code> 集成 <code>Mybatis</code>的方式有很多种，大家耳熟能详的<code>xml</code>配置方式或者本文的采用的方式：<br/>
首先需要添加<code>MyBatis</code>的和<code>MyBatis-Spring</code>的依赖，本文使用的<code>Spring-mybatis</code>版本是1.3.1。在<code>mvnrepository</code>里面我们可以找到当前<code>Spring-mybatis</code>依赖的<code>spring</code>和<code>mybatis</code>版本，最好是选择匹配的版本以避免处理不必要的兼容性问题。因为<code>MyBatis-Spring</code>中对<code>mybatis</code>的依赖选择了<code>provided</code>模式，所以我们不得不额外添加<code>mybatis</code>依赖，依赖配置如下。
<code>xml pom.xml
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;1.3.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
      &lt;version&gt;3.4.1&lt;/version&gt;
&lt;/dependency&gt;
</code>
接下来会我们要创建工厂bean,放置下面的代码在 Spring 的 XML 配置文件中:<br/>
<code>xml applicationContext.xml
&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;
  &lt;property name="dataSource" ref="dataSource" /&gt;
&lt;/bean&gt;
</code><br/>
这个工厂需要一个<code>DataSource</code>，就是我们熟知的数据源了。这里我们选择了阿里的<code>Druid</code>，同样我们需要引入两个配置
<code>xml pom.xml
&lt;dependency&gt;
 &lt;groupId&gt;mysql&lt;/groupId&gt;
 &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
 &lt;version&gt;5.1.41&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
 &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
 &lt;artifactId&gt;druid&lt;/artifactId&gt;
 &lt;version&gt;1.1.2&lt;/version&gt;
&lt;/dependency&gt;
</code>          <br/>
添加<code>Spring</code>配置如下
<code>xml applicationContext.xml
&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt;
        &lt;!-- 基本属性 url、user、password --&gt;
        &lt;property name="url"&gt;
            &lt;value&gt;&lt;![CDATA[${db.url}]]&gt;&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="username" value="${db.username}"/&gt;
        &lt;property name="password" value="${db.password}"/&gt;       
        &lt;!-- 省略其他配置 --&gt;   
&lt;/bean&gt;
</code>
接下来我们要编写数据库访问对象，大多数人会把它叫做<code>DAO</code>或者<code>Repository</code>，在这里其被称为<code>Mapper</code>，也是因为它的实现方式所决定。要注意的是所指定的映射器类必须是一个接口，而不是具体的实现类。这便因为<code>Mybatis</code>的内部实现使用的是<code>Java动态代理</code>，而<code>Java动态代理</code>只支持接口，关于<code>动态代理</code>我们下文有更详细的描述。
<code>java UserMapper.java
public interface UserMapper {
  @Select("SELECT * FROM users WHERE id = #{userId}")
  User getUser(@Param("userId") String userId);
}
</code>
接下来可以使用 <code>MapperFactoryBean</code>,像下面这样来把接口加入到 <code>Spring</code> 中，这样就把 <code>UserMapper</code> 和 <code>SessionFactory</code>关联到一起了，原来使用<code>xml</code>配置的时候还需要Dao继承<code>SqlSessionDaoSupport</code>才能注入<code>SessionFactory</code>，这种方式直接通过<code>Java动态代理</code>把<code>SqlSessionFactory</code>代理给了<code>UserMapper</code>，使得我们直接使用<code>UserMapper</code>即可。配置如下。
<code>xml applicationContext.xml
&lt;bean id="userMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt;
  &lt;property name="mapperInterface" value="org.mybatis.spring.sample.mapper.UserMapper" /&gt;
  &lt;property name="sqlSessionFactory" ref="sqlSessionFactory" /&gt;
&lt;/bean&gt;
</code>
这样我们已经完成了90%，就差调用了，前提是你<code>Spring</code>环境是OK的。调用 <code>MyBatis</code> 数据方法现在只需一行代码:
&#8220;`java FooServiceImpl.java
public class FooServiceImpl implements FooService {</p>

<p>private UserMapper userMapper;</p>

<p>public void setUserMapper(UserMapper userMapper) {
  this.userMapper = userMapper;
}</p>

<p>public User doSomeBusinessStuff(String userId) {
  return this.userMapper.getUser(userId);
}
<code>
那么问题又来了，每次写一个DAO都需要为其写一个`Bean`配置，那不是累死？于是我们又寻找另一种方案，代替手动声明`*Mapper`。`MapperScannerConfigurer`的出现解决了这个问题， 它会根据你配置的包路径自动的扫描类文件并自动将它们创建成`MapperFactoryBean`，可以在 Spring 的配置中添加如下代码:
</code>xml applicationContext.xml
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
  <property name="basePackage" value="com.github.codedrinker.mapper" />
</bean>
<code>
`basePackage`属性是让你为映射器接口文件设置基本的包路径。你可以使用分号或逗号作为分隔符设置多于一个的包路径。这个时候如果想自定义`sqlSessionFactory`可以添加如下配置：
</code>xml applicationContext.xml
<property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" />
<code>``
这样以后还有一点点小瑕疵，如果我们数据的</code>column<code>名字是</code>_<code>连接的，那么它不会那么聪明自动转换为驼峰的变量，所以我们需要对</code>SqlSessionFactoryBean`做如下配置，但是在1.3.0以后才可以通过xml配置，如果用早起版本的需要注意了。</p>

<pre><code class="xml applicationContext.xml">&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;
  &lt;property name="dataSource" ref="dataSource" /&gt;
  &lt;property name="configuration"&gt;
    &lt;bean class="org.apache.ibatis.session.Configuration"&gt;
      &lt;property name="mapUnderscoreToCamelCase" value="true"/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p>至此关于<code>Spring MyBatis</code>的配置已经全部结束，后面我们会简单说下<code>Spring MyBatis</code>中的动态代理。</p>

<h2>浅析 Java 动态代理</h2>

<p><code>JDK</code>自带的动态代理需要了解InvocationHandler接口和Proxy类，他们都是在java.lang.reflect包下。<br/>
<code>InvocationHandler</code>是代理实例的调用处理程序实现的接口。每个代理实例都具有一个关联的<code>InvocationHandler</code>。对代理实例调用方法时，这个方法会调用<code>InvocationHandler</code>的<code>invoke</code>方法。
<code>Proxy</code>提供静态方法用于创建动态代理类和实例,同时后面自动生成的代理类都是<code>Proxy</code>对象。下面我们直接通过代码来分析<code>Java动态代理</code>：
<code>InvocationInterceptor</code>实现<code>InvocationHandler</code>接口，用于处理具体的代理逻辑。
&#8220;`java InvocationInterceptor.java
/<em>*
 * Created by codedrinker on 12/10/2017.
 </em>/
public class InvocationInterceptor implements InvocationHandler {
    private Object target;</p>

<pre><code>public InvocationInterceptor(Object target) {
    this.target = target;
}
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    System.out.println("before user create");
    method.invoke(target, args);
    System.out.println("end user create");
    return null;
}
</code></pre>

<p>}
<code>
`User`和`UserImpl`是被代理对象的接口和类
</code>java User.java
/<em>*
 * Created by codedrinker on 12/10/2017.
 </em>/
public interface User {
    void create();
}</p>

<p><code>
</code>java UserImpl.java
/<strong>
 * Created by codedrinker on 12/10/2017.
 */
public class UserImpl implements User {
    @Override
    public void create() {
        System.out.println(&ldquo;create user&rdquo;);
    }
}
<code>
`DynamicProxyTest`是测试类，用于创建`InvocationInterceptor`和`Proxy`类以便测试。
</code>java DynamicProxyTest.java
/</strong>
 * Created by codedrinker on 12/10/2017.
 <em>/
public class DynamicProxyTest {
    public static void main(String[] args) {
        User target = new UserImpl();
        InvocationInterceptor invocationInterceptor = new InvocationInterceptor(target);
        User proxyInstance = (User) Proxy.newProxyInstance(UserImpl.class.getClassLoader(),
                UserImpl.class.getInterfaces(),
                invocationInterceptor);
        proxyInstance.create();
    }
}
<code>
输入结果如下：
</code>sh
before user create
create user
end user create
<code>
很明显，我们通过proxyInstance这个代理类进行方法调用的时候，会在方法调用前后进行输出打印，这样就简单的实现了一个`Java动态代理`例子。动态代理不仅仅是打印输出这么简单，我们可以通过它打印日志，打开关闭事务， 权限检查了等等。当然它更是许多框架的钟爱，就如下文我们要说的`MyBatis`中`Java动态代理`的实现。再多说一句`Spring`的`AOP`也是使用动态代理实现的，当然它同时使用了`Java动态代理`和`CGLib`两种方式。不过`CGLIB`不是本文要讨论的范围。  
注意观察的同学看到上面代码的时候可能发现`invoke`方法的`proxy`参数并没有被使用，笔者查阅了一些相关文档也没有找到合理的说法，只能在源码中看看究竟喽，笔者当前的JDK版本是1.8。我们从入口开始，`Proxy.newProxyInstance`:
</code>java Proxy.java片段
/</em>
 * Look up or generate the designated proxy class.
 */
@CallerSensitive
public static Object newProxyInstance(ClassLoader loader,
                                      Class&lt;?>[] interfaces,
                                      InvocationHandler h)
    throws IllegalArgumentException
{
    Class&lt;?> cl = getProxyClass0(loader, intfs);
}
<code>
如上代码由此可见，它调用了`getProxyClass0`来获取`Proxy Class`，那我们继续往下看。
</code>java Proxy.java片段
private static Class&lt;?> getProxyClass0(ClassLoader loader,
                                           Class&lt;?>&hellip; interfaces) {
    if (interfaces.length > 65535) {
        throw new IllegalArgumentException(&ldquo;interface limit exceeded&rdquo;);
    }
    //If the proxy class defined by the given loader implementing
    //the given interfaces exists, this will simply return the cached copy;
    //otherwise, it will create the proxy class via the ProxyClassFactory
    return proxyClassCache.get(loader, interfaces);
}
<code>
其实上面写的已经很简单了，如果存在就在`proxyClassCache`里面获取到，如果不存在就使用`ProxyClassFactory`创建一个。当然我们如果看一下`proxyClassCache`变量的话其也是`ProxyClassFactory`对象。
</code>java
   private static final WeakCache&lt;ClassLoader, Class&lt;?>[], Class&lt;?>>
        proxyClassCache = new WeakCache&lt;>(new KeyFactory(), new ProxyClassFactory());
<code>
那么我们直接就去查看`ProxyClassFactory`的实现问题不就解决了吗？
</code>java Proxy.java片段
    private static final class ProxyClassFactory
        implements BiFunction&lt;ClassLoader, Class&lt;?>[], Class&lt;?>>
    {
        // prefix for all proxy class names
        private static final String proxyClassNamePrefix = &ldquo;$Proxy&rdquo;;
        //next number to use for generation of unique proxy class names
        private static final AtomicLong nextUniqueNumber = new AtomicLong();
        @Override
        public Class&lt;?> apply(ClassLoader loader, Class&lt;?>[] interfaces) {</p>

<pre><code>        String proxyName = proxyPkg + proxyClassNamePrefix + num;
        /*
         * Generate the specified proxy class.
         */
        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
            proxyName, interfaces, accessFlags);
    }
}
</code></pre>

<pre><code>由上代码便一目了然了，为什么我们`Debug`的时候`Proxy`对象是`$Proxy0`，是因为他通过`$Proxy`和`AtomicLong`拼起来的类名，其实这不是重点。重点是`ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags)`。这就是生成`class`的地方，它把所有的条件组合好，生成`class`文件，然后再加载到内存里面以供使用。有兴趣的同学可以继续往深处查看。而我们需要做的是获取到他生成的字节码，看一下里面到底是什么？当`saveGeneratedFiles`为`true`的时候会保存`class`文件，所以我们在`DynamicProxyTest`的`main`函数添加一行即可：
</code></pre>

<p>System.setProperty(&ldquo;sun.misc.ProxyGenerator.saveGeneratedFiles&rdquo;, &ldquo;true&rdquo;);
<code>
通过`Debug`我们可以发现，它存储`class`文件的路径是`com/sun/proxy/$Proxy0.class`，所以直接在我们项目的目录下面就能找到它，然后通过`Idea`打开便得到如下代码：
</code>java $Proxy0.class
public final class $Proxy0 extends Proxy implements User {
    private static Method m1;
    private static Method m2;
    private static Method m3;
    private static Method m0;</p>

<pre><code>public $Proxy0(InvocationHandler var1) throws  {
    super(var1);
}

public final boolean equals(Object var1) throws  {
    try {
        return ((Boolean)super.h.invoke(this, m1, new Object[]{var1})).booleanValue();
    } catch (RuntimeException | Error var3) {
        throw var3;
    } catch (Throwable var4) {
        throw new UndeclaredThrowableException(var4);
    }
}

public final String toString() throws  {
    try {
        return (String)super.h.invoke(this, m2, (Object[])null);
    } catch (RuntimeException | Error var2) {
        throw var2;
    } catch (Throwable var3) {
        throw new UndeclaredThrowableException(var3);
    }
}

public final void create() throws  {
    try {
        super.h.invoke(this, m3, (Object[])null);
    } catch (RuntimeException | Error var2) {
        throw var2;
    } catch (Throwable var3) {
        throw new UndeclaredThrowableException(var3);
    }
}

public final int hashCode() throws  {
    try {
        return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();
    } catch (RuntimeException | Error var2) {
        throw var2;
    } catch (Throwable var3) {
        throw new UndeclaredThrowableException(var3);
    }
}

static {
    try {
        m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[]{Class.forName("java.lang.Object")});
        m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]);
        m3 = Class.forName("local.dynimicproxy.User").getMethod("create", new Class[0]);
        m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);
    } catch (NoSuchMethodException var2) {
        throw new NoSuchMethodError(var2.getMessage());
    } catch (ClassNotFoundException var3) {
        throw new NoClassDefFoundError(var3.getMessage());
    }
}
</code></pre>

<p>}
<code>``
这样好多问题就迎刃而解。  
为什么</code>Java动态代理<code>必须是接口，因为生成的类要去实现这个接口。  
</code>invoke<code>方法的</code>proxy<code>是干嘛的，通过</code>super.h.invoke(this, m3, (Object[])null);<code>我们可以发现传递给</code>invoke<code>方法的就是</code>Proxy<code>本身。  
同时</code>Proxy<code>类也通过反射实现了</code>toString<code>,</code>equals<code>,和</code>hashcode<code>等方法。  
自此关于</code>Java动态代理<code>的讲解已经告段落，下面让我们简单看一下</code>Spring-mybatis<code>中关于</code>Java动态代理`的使用。</p>

<h2>Java动态代理在Spring-mybatis中的实现</h2>

<p>关于<code>Spring-mybatis</code>的实现我们得从<code>MapperScannerConfigurer</code>说起，首先<code>MapperScannerConfigurer</code>实现了<code>BeanDefinitionRegistryPostProcessor</code>接口。而<code>BeanDefinitionRegistryPostProcessor</code>依赖于<code>Spring</code>框架，简单的说<code>BeanDefinitionRegistryPostProcessor</code>使得我们可以将<code>BeanDefinition</code>添加到<code>BeanDefinitionRegistry</code>中，而<code>BeanDefinition</code>描述了一个Bean实例所拥有的实例、结构参数和参数值，简单点说拥有它就可以实例化<code>Bean</code>了。<code>BeanDefinitionRegistryPostProcessor</code>的<code>postProcessBeanDefinitionRegistry</code>方法在<code>Bean</code>被定义但还没被创建的时候执行，所以<code>Spring-mybatis</code>也是借助了这一点。需要想需要更深入的了解可以查看<code>Spring</code>的生命周期。
<code>java MapperScannerConfigurer.java片段
public class MapperScannerConfigurer implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware {
  /**
   * {@inheritDoc}
   *
   * @since 1.0.2
   */
  @Override
  public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
    scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));
  }
</code>
由上代码我们可以看到在<code>postProcessBeanDefinitionRegistry</code>里面得到<code>registry</code>然后使用<code>ClassPathMapperScanner</code>开始扫描包路径得到的<code>Bean</code>并且注册到<code>registry</code>里面。我们接着往里面看。
&#8220;`java ClassPathMapperScanner.java
@Override
public Set<BeanDefinitionHolder> doScan(String&hellip; basePackages) {
Set<BeanDefinitionHolder> beanDefinitions = super.doScan(basePackages);</p>

<p>if (beanDefinitions.isEmpty()) {
  logger.warn(&ldquo;No MyBatis mapper was found in &lsquo;&rdquo; + Arrays.toString(basePackages) + &ldquo;&rsquo; package. Please check your configuration.&rdquo;);
} else {
  processBeanDefinitions(beanDefinitions);
}</p>

<p>return beanDefinitions;
}
<code>
`ClassPathMapperScanner`继承了`Spring`的`ClassPathBeanDefinitionScanner`所以调用父类的`doScan`方法就可以加载`Bean`然后再通过`processBeanDefinitions`方法加工成`MyBatis`需要的`Bean`。
</code>java ClassPathMapperScanner.java片段
private void processBeanDefinitions(Set<BeanDefinitionHolder> beanDefinitions) {
    GenericBeanDefinition definition;
    for (BeanDefinitionHolder holder : beanDefinitions) {
      definition = (GenericBeanDefinition) holder.getBeanDefinition();
      definition.setBeanClass(this.mapperFactoryBean.getClass());
    }
  }
<code>
如上代码循环了所有由`Spring`容器解析出来的`beanDefinitions`然后把他们的`BeanClass`修改为`mapperFactoryBean`，这就进入了行文的重点。我们翻看到`MapperFactoryBean`:
</code>java MapperFactoryBean.java片段
@Override
protected void checkDaoConfig() {
super.checkDaoConfig();</p>

<p>notNull(this.mapperInterface, &ldquo;Property &lsquo;mapperInterface&rsquo; is required&rdquo;);</p>

<p>Configuration configuration = getSqlSession().getConfiguration();
if (this.addToConfig &amp;&amp; !configuration.hasMapper(this.mapperInterface)) {
  try {
    configuration.addMapper(this.mapperInterface);
  } catch (Exception e) {
    logger.error(&ldquo;Error while adding the mapper &lsquo;&rdquo; + this.mapperInterface + &ldquo;&rsquo; to configuration.&rdquo;, e);
    throw new IllegalArgumentException(e);
  } finally {
    ErrorContext.instance().reset();
  }
}
}
<code>
其调用了`Configuration`的`addMapper`方法，这样就把`Bean`交给`MyBatis`管理了。那么`checkDaoConfig`是什么时候调用的呢？我们翻看其父类`DaoSupport`可以看到:
</code>java DaoSupport.java片段
public abstract class DaoSupport implements InitializingBean {
    @Override
  public final void afterPropertiesSet() throws IllegalArgumentException, BeanInitializationException {
    checkDaoConfig();
  }
}
<code>
因为`DaoSupport`实现了`InitializingBean`并重写`afterPropertiesSet`方法，了解`Spring`生命周期的同学知道`afterPropertiesSet`方法会在资源加载完以后，初始化bean之前执行。我们继续查看`addMapper`方法。
</code>java MapperRegistry.java片段
public <T> void addMapper(Class<T> type) {
    if (type.isInterface()) {
      if (hasMapper(type)) {
        throw new BindingException(&ldquo;Type &rdquo; + type + &ldquo; is already known to the MapperRegistry.&rdquo;);
      }
      boolean loadCompleted = false;
      try {
        knownMappers.put(type, new MapperProxyFactory<T>(type));
        // It&rsquo;s important that the type is added before the parser is run
        // otherwise the binding may automatically be attempted by the
        // mapper parser. If the type is already known, it won&rsquo;t try.
        MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
        parser.parse();
        loadCompleted = true;
      } finally {
        if (!loadCompleted) {
          knownMappers.remove(type);
        }
      }
    }
}
<code>
`addMapper`方法最终创建了`MapperProxyFactory`对象，在`MapperProxyFactory`里面我们两眼泪汪汪地发现了似曾相识的代码：
</code>java MapperProxyFactory.java片段
protected T newInstance(MapperProxy<T> mapperProxy) {
    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);
}</p>

<p>public T newInstance(SqlSession sqlSession) {
    final MapperProxy<T> mapperProxy = new MapperProxy<T>(sqlSession, mapperInterface, methodCache);
    return newInstance(mapperProxy);
}
<code>
而`MapperProxy`实现了`InvocationHandler`方法，最终实现对`Bean`的代理，同时获取到上下文的`sqlSession`以供使用。具体生成过程我们不再累述，直接通过其源码结束本篇文章：
</code>java MapperProxy.java片段
public class MapperProxy<T> implements InvocationHandler, Serializable {</p>

<p>  private static final long serialVersionUID = -6424540398559729838L;
  private final SqlSession sqlSession;
  private final Class<T> mapperInterface;
  private final Map&lt;Method, MapperMethod> methodCache;</p>

<p>  public MapperProxy(SqlSession sqlSession, Class<T> mapperInterface, Map&lt;Method, MapperMethod> methodCache) {
    this.sqlSession = sqlSession;
    this.mapperInterface = mapperInterface;
    this.methodCache = methodCache;
  }</p>

<p>  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    try {
      if (Object.class.equals(method.getDeclaringClass())) {
        return method.invoke(this, args);
      } else if (isDefaultMethod(method)) {
        return invokeDefaultMethod(proxy, method, args);
      }
    } catch (Throwable t) {
      throw ExceptionUtil.unwrapThrowable(t);
    }
    final MapperMethod mapperMethod = cachedMapperMethod(method);
    return mapperMethod.execute(sqlSession, args);
  }
}
&#8220;`</p>

<h2>参考链接</h2>

<p><a href="http://www.mybatis.org/spring/getting-started.html">Spring Mybatis 配置</a>  <br/>
<a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/">Spring Boot Mybatis</a><br/>
<a href="https://stackoverflow.com/questions/22930195/understanding-proxy-arguments-of-the-invoke-method-of-java-lang-reflect-invoca">InvocationHandler Proxy Parameter</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Idea 创建 Spring Boot 项目]]></title>
    <link href="http://www.majiang.life/blog/spring-boot-get-started/"/>
    <updated>2017-06-22T22:22:14+08:00</updated>
    <id>http://www.majiang.life/blog/spring-boot-get-started</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>最近 <code>Spring Boot</code> 如火如荼，于是也开始试试，不过上手真的太简单了。<code>Idea</code>非常方便的就可以创建，或者直接<code>clone</code>官方的例子<a href="https://spring.io/guides/gs/spring-boot/">https://spring.io/guides/gs/spring-boot/</a>。通俗理解<code>Spring Boot</code>就是一个<code>平台</code>，让你非常便捷的构建和运行一个项目，并且他是基于组件化的，你想用什么直接<code>拿来主义</code>就可以了，话不多少直接上手。</p>

<!-- more -->


<h2>使用 <code>Idea</code> 快速搭建</h2>

<p>选择<code>Spring Initialiar</code>直接创建。
<img src="/images/posts/spring-boot-get-started-1.png" alt="spring-boot-get-started-1" /></p>

<p>填写好<code>Group</code>和<code>Artifact</code>。
<img src="/images/posts/spring-boot-get-started-2.png" alt="spring-boot-get-started-2" /></p>

<p>下面直接选择<code>Web</code>就可以了，但是如果你想选择其他的直接勾选就行，她会自动为你加载依赖。并且一些<code>dependency</code>不需要配置版本，每一个<code>Spring Boot</code>的<code>parent</code>项目集成管理，这样省去了好多兼容麻烦。
<img src="/images/posts/spring-boot-get-started-3.png" alt="spring-boot-get-started-3" /></p>

<p>我们写一个<code>HelloController</code>试一下效果。
<img src="/images/posts/spring-boot-get-started-4.png" alt="spring-boot-get-started-4" /></p>

<p>最后访问<code>http://localhost:8080</code>成功。
<img src="/images/posts/spring-boot-get-started-5.png" alt="spring-boot-get-started-5" /></p>

<p>如果想改变端口也是非常简单的。
<img src="/images/posts/spring-boot-get-started-6.png" alt="spring-boot-get-started-6" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[优雅的使用 ThreadLocal 传递参数]]></title>
    <link href="http://www.majiang.life/blog/the-smart-way-of-passing-parameter-by-threadlocal/"/>
    <updated>2017-05-20T18:04:38+08:00</updated>
    <id>http://www.majiang.life/blog/the-smart-way-of-passing-parameter-by-threadlocal</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>在我们日常 <code>Web</code> 开发中难免遇到需要把一个参数层层的传递到最内层，然后中间层根本不需要使用这个参数，或者是仅仅在特定的工具类中使用，这样我们完全没有必要在每一个方法里面都传递这样一个<code>通用</code>的参数。如果有一个办法能够在任何一个类里面想用的时候直接拿来使用就太好了。<code>Java</code>的<code>Web</code>项目大部分都是基于<code>Tomcat</code>，每次访问都是一个新的线程，这样让我们联想到了<code>ThreadLocal</code>，每一个线程都独享一个<code>ThreadLocal</code>，在接收请求的时候<code>set</code>特定内容，在需要的时候<code>get</code>这个值。下面我们就进入主题。</p>

<!-- more -->


<h2>ThreadLocal</h2>

<p>维持线程封闭性的一种更规范的方法就是使用<code>ThreadLocal</code>，这个类能使线程中的某个值与保存的值的对象关联起来。<code>ThreadLocal</code>提供<code>get</code>和<code>set</code>等接口或方法，这些方法为每一个使用这个变量的线程都存有一份独立的副本，因此<code>get</code>总是返回由当前线程在调用<code>set</code>时设置的最新值。
<code>ThreadLocal</code>有如下方法
<code>java
public T get() { }
public void set(T value) { }
public void remove() { }
protected T initialValue() { }
</code>
<code>get()</code>方法是用来获取<code>ThreadLocal</code>在当前线程中保存的变量副本<br/>
<code>set()</code>用来设置当前线程中变量的副本<br/>
<code>remove()</code>用来移除当前线程中变量的副本 <br/>
<code>initialValue()</code>是一个<code>protected</code>方法，一般是用来在使用时进行重写的，如果在没有set的时候就调用<code>get</code>，会调用<code>initialValue</code>方法初始化内容。
为了使用的更放心，我们简单的看一下具体的实现:</p>

<h3><code>set</code>方法</h3>

<pre><code class="java ThreadLocal.java">public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }
</code></pre>

<p><code>set</code>方法会获取当前的线程，通过当前线程获取<code>ThreadLocalMap</code>对象。然后把需要存储的值放到这个<code>map</code>里面。如果没有就调用<code>createMap</code>创建对象。</p>

<h3><code>getMap</code>方法</h3>

<pre><code class="java ThreadLocal.java"> ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }
</code></pre>

<p><code>getMap</code>方法直接返回当前<code>Thread</code>的<code>threadLocals</code>变量，这样说明了之所以说<code>ThreadLocal</code>是<code>线程局部变量</code>就是因为它只是通过<code>ThreadLocal</code>把<code>变量</code>存在了<code>Thread</code>本身而已。</p>

<h3><code>createMap</code>方法</h3>

<pre><code class="java ThreadLocal.java">void createMap(Thread t, T firstValue) {
        t.threadLocals = new ThreadLocalMap(this, firstValue);
    }
</code></pre>

<p>在<code>set</code>的时候如果不存在<code>threadLocals</code>，直接创建对象。由上看出，放入<code>map</code>的<code>key</code>是当前的<code>ThreadLocal</code>，<code>value</code>是需要存放的内容，所以我们设置属性的时候需要注意存放和获取的是一个<code>ThreadLocal</code>。</p>

<h3><code>get</code>方法</h3>

<pre><code class="java ThreadLocal.java">public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null)
                return (T)e.value;
        }
        return setInitialValue();
    }
</code></pre>

<p><code>get</code>方法就比较简单，获取当前线程，尝试获取当前线程里面的<code>threadLocals</code>，如果没有获取到就调用<code>setInitialValue</code>方法，<code>setInitialValue</code>基本和<code>set</code>是一样的，就不累累述了。</p>

<h2>场景</h2>

<p>本文应用<code>ThreadLocal</code>的场景：在调用API接口的时候传递了一些公共参数，这些公共参数携带了一些设备信息，服务端接口根据不同的信息组装不同的格式数据返回给客户端。假定服务器端需要通过设备类型(device)来下发下载地址，当然接口也有同样的其他逻辑，我们只要在返回数据的时候判断好是什么类型的客户端就好了。如下:</p>

<h4>场景一</h4>

<p>请求
<code>sh
GET api/users?device=android
</code>
返回
<code>JSON
    {
        user : {        
        },
        link : "https://play.google.com/store/apps/details?id=***"
    }
</code></p>

<h4>场景二</h4>

<p>请求
<code>sh
GET api/users?device=ios
</code>
返回
<code>JSON
    {
        user : {    
        },
        link : "https://itunes.apple.com/us/app/**"
    }
</code></p>

<h2>实现</h2>

<p>首先准备一个<code>BaseSigntureRequest</code>类用来存放公共参数
&#8220;`java BaseSignatureRequest.java
public class BaseSignatureRequest {
    private String device;</p>

<pre><code>public String getDevice() {
    return device;
}

public void setDevice(String device) {
    this.device = device;
}
</code></pre>

<p>}
<code>
然后准备一个`static`的`ThreadLocal`类用来存放`ThreadLocal`，以便存储和获取时候的`ThreadLocal`一致。
</code>java ThreadLocalCache.java
public class ThreadLocalCache {
    public static ThreadLocal<BaseSignatureRequest>
        baseSignatureRequestThreadLocal = new ThreadLocal&lt;>();
}
<code>
然后编写一个`Interceptor`，在请求的时候获取`device`参数，存入当前线程的`ThreadLocal`中。这里需要注意的是，重写了`afterCompletion`方法，当请求结束的时候把`ThreadLocal` `remove`，移除不必须要键值对。
</code>java ParameterInterceptor.java
public class ParameterInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
                             Object handler) throws Exception {
        String device = request.getParameter(&ldquo;device&rdquo;);
        BaseSignatureRequest baseSignatureRequest = new BaseSignatureRequest();
        baseSignatureRequest.setDevice(device);
        ThreadLocalCache.baseSignatureRequestThreadLocal.set(baseSignatureRequest);
        return true;
    }</p>

<pre><code>@Override
public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
                            Object handler, Exception ex) throws Exception {
    ThreadLocalCache.baseSignatureRequestThreadLocal.remove();
}

@Override
public void postHandle(HttpServletRequest httpServletRequest,
                       HttpServletResponse httpServletResponse, 
                       Object o, ModelAndView modelAndView) throws Exception {

}
</code></pre>

<p>}
<code>
当然需要在`spring`里面配置`interceptor`
</code>xml applicationContext.xml
    &lt;mvc:interceptors>
        &lt;mvc:interceptor>
            &lt;mvc:mapping path=&ldquo;/api/**&rdquo;/>
            <bean class="life.majiang.ParameterInterceptor"></bean>
        &lt;/mvc:interceptor>
    &lt;/mvc:interceptors>
&#8220;`</p>

<p>最后在<code>Converter</code>里面转换实体的时候直接使用即可，这样就大功告成了。
<code>java UserConverter.java
public class UserConverter {
    public static ResultDO toDO(User user) {
        ResultDO resultDO = new ResultDO();
        resultDO.setUser(user);
        BaseSignatureRequest baseSignatureRequest = ThreadLocalCache.baseSignatureRequestThreadLocal.get();
        String device = baseSignatureRequest.getDevice();
        if (StringUtils.equals(device, "ios")) {
            resultDO.setLink("https://itunes.apple.com/us/app/**");
        } else {
            resultDO.setLink("https://play.google.com/store/apps/details?id=***");
        }
        return resultDO;
    }
</code></p>

<h2>总结</h2>

<p>这种机制很方便，因为他避免了在调用每一个方法时都要传递执行上下文信息，合理的使用<code>ThreadLocal</code>可以起到事倍功半的效果，但是需要避免滥用，例如将所有的全局变量作为<code>ThreadLocal</code>对象，<code>ThreadLocal</code>类似全局变量，他能降低代码的可重用性，并在类之间引入隐含的耦合性，所以再使用前需要格外小心。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[构建 Java 应用内存级缓存]]></title>
    <link href="http://www.majiang.life/blog/simple-in-memory-cache-in-java/"/>
    <updated>2017-04-30T10:49:21+08:00</updated>
    <id>http://www.majiang.life/blog/simple-in-memory-cache-in-java</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>缓存是我们日常开发中是必不可少的一种解决性能问题的方法。早期Cache只应用在CPU和内存之间，现在遍布在每一个角落，内存和磁盘，磁盘和网路都存在Cache。Cache同样是做Java应用必不可少的元素。缓存在各种用例中非常有用。例如，当一个值计算或检索成本高昂时，应该考虑使用高速缓存，并且需要在某个输入上多次使用它的值。通常我们使用的缓存有<code>分布式的缓存数据库</code>,<code>本机的缓存数据库</code>,<code>本地的内存缓存</code>，当然也有直接使用数据库的。无论我们选择哪一种实现，都需要结合自身的机器配置和网路情况考虑，毕竟内存，网路带宽都是量化的。下面的表格来源于<a href="https://research.google.com/pubs/jeff.html"> Jeff Dean</a>的一个PPT，里面罗列了不同级别的IO时间，这正是我们评估如何设计我们系统的必要因素。
<br></p>

<table>
<thead>
<tr>
<th style="text-align:left;">                                   </th>
<th style="text-align:left;">               </th>
<th style="text-align:left;">         </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">L1 cache reference                 </td>
<td style="text-align:left;"> 0.5 ns        </td>
<td style="text-align:left;">         </td>
</tr>
<tr>
<td style="text-align:left;">Branch mispredict                  </td>
<td style="text-align:left;"> 5 ns          </td>
<td style="text-align:left;">         </td>
</tr>
<tr>
<td style="text-align:left;">L2 cache reference                 </td>
<td style="text-align:left;"> 7 ns          </td>
<td style="text-align:left;">         </td>
</tr>
<tr>
<td style="text-align:left;">Mutex lock/unlock                  </td>
<td style="text-align:left;"> 100 ns        </td>
<td style="text-align:left;">         </td>
</tr>
<tr>
<td style="text-align:left;">Main memory reference              </td>
<td style="text-align:left;"> 100 ns        </td>
<td style="text-align:left;">         </td>
</tr>
<tr>
<td style="text-align:left;">Compress 1K bytes with Zippy       </td>
<td style="text-align:left;"> 10,000 ns     </td>
<td style="text-align:left;"> 0.01 ms </td>
</tr>
<tr>
<td style="text-align:left;">Send 1K bytes over 1 Gbps network  </td>
<td style="text-align:left;"> 10,000 ns     </td>
<td style="text-align:left;"> 0.01 ms </td>
</tr>
<tr>
<td style="text-align:left;">Read 1 MB sequentially from memory </td>
<td style="text-align:left;"> 250,000 ns    </td>
<td style="text-align:left;"> 0.25 ms </td>
</tr>
<tr>
<td style="text-align:left;">Round trip within same datacenter  </td>
<td style="text-align:left;"> 500,000 ns    </td>
<td style="text-align:left;"> 0.5 ms  </td>
</tr>
<tr>
<td style="text-align:left;">Disk seek                          </td>
<td style="text-align:left;"> 10,000,000 ns </td>
<td style="text-align:left;"> 10 ms   </td>
</tr>
<tr>
<td style="text-align:left;">Read 1 MB sequentially from network</td>
<td style="text-align:left;"> 10,000,000 ns </td>
<td style="text-align:left;"> 10 ms   </td>
</tr>
<tr>
<td style="text-align:left;">Read 1 MB sequentially from disk   </td>
<td style="text-align:left;"> 30,000,000 ns </td>
<td style="text-align:left;"> 30 ms   </td>
</tr>
<tr>
<td style="text-align:left;">Send packet CA->Netherlands->CA    </td>
<td style="text-align:left;"> 150,000,000 ns</td>
<td style="text-align:left;"> 150 ms  </td>
</tr>
</tbody>
</table>


<!-- more -->


<p><br><br/>
由上面表格，我们可以清楚的看出从网络上面获取1M数据和从内存中读取1M数据的差别。为什么说到这里呢，因为随着我们的用户的增加，集群的扩展，很少的情况下是把缓存数据库或者其他缓存中间件和应用程序放在一台服务器上，大部分情况都是分布式的应用系统和缓存系统，所以避免不了的我们需要考虑网络而的开销。然后网络的读取和本地的读取差别如此之大，进而引出了今天的话题，适当的使用Java应用内存级别的缓存。针对一些基本不变的数据，或者是变化不大，使用非常频繁的数据可以考虑采用Java应用内存级别缓存。</p>

<h2>Guava Cache</h2>

<p>这篇文章讲的是如何使用<code>Guava Cache</code>构建Java内存基本的缓存，<code>Guava Cache</code>缓存类似于<code>ConcurrentMap</code>，但不完全相同。 最根本的区别是，ConcurrentMap会持续添加到其中的所有元素，如果你不手动删除它们会一直存在。然而<code>Guava Cache</code>可以通过缓存的大小，过期时间，或者其他策略自动地移除元素，来限制其内存占用。<code>Guava Cache</code>有两种方式实现，一种是<code>CacheLoader</code>在定义的时候就设置好缓存的源，另一种是<code>Callable</code>在调用缓存的时候指定如果缓存中没有的获取的方式，长话短说，我们直接进入正题。</p>

<h2>依赖</h2>

<p>笔者项目使用<code>Maven</code>构建，直接使用如下配合文件
<code>xml pom.xml
&lt;dependency&gt;
    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
    &lt;artifactId&gt;guava&lt;/artifactId&gt;
    &lt;version&gt;19.0&lt;/version&gt;
&lt;/dependency&gt;
</code></p>

<h2>CacheLoader</h2>

<p>预先准备好一个<code>MockDB</code>类，用来模拟缓存中没有的时候在数据库中获取
{% codeblock lang:java MockDB.java%}
{% raw %}
public class MockDB {
    private static Map&lt;String, String> mockPersistence = new HashMap&lt;String, String>() {{
        this.put(&ldquo;github&rdquo;, &ldquo;codedrinker&rdquo;);
    }};</p>

<pre><code>public static String loadFromPersistence(String key) {
    System.out.println("load key from persistence : " + key);
    return mockPersistence.get(key);
}
</code></pre>

<p>}
{% endraw %}
{% endcodeblock %}
下面是使用<code>CacheLoader</code>的代码
{% codeblock lang:java GuavaLoadingCache.java%}
{% raw %}
public class GuavaLoadingCache {
    public static void main(String[] args) {
        LoadingCache&lt;String, Optional<String>> loadingCache = CacheBuilder
                .newBuilder()
                .expireAfterWrite(3, TimeUnit.SECONDS)
                .removalListener(new RemovalListener&lt;String, Optional<String>>() {
                    @Override
                    public void onRemoval(RemovalNotification&lt;String, Optional<String>> notification) {
                        System.out.println(&ldquo;cache expired, remove key : &rdquo; + notification.getKey());
                    }
                })
                .build(new CacheLoader&lt;String, Optional<String>>() {
                    @Override
                    public Optional<String> load(String key) throws Exception {
                        return Optional.fromNullable(MockDB.loadFromPersistence(key));
                    }
                });
        try {
            System.out.println(&ldquo;load from cache once : &rdquo; + loadingCache.get(&ldquo;github&rdquo;).orNull());
            Thread.sleep(2000);
            System.out.println(&ldquo;load from cache twice : &rdquo; + loadingCache.get(&ldquo;github&rdquo;).orNull());
            Thread.sleep(2000);
            System.out.println(&ldquo;load from cache third : &rdquo; + loadingCache.get(&ldquo;github&rdquo;).orNull());
            Thread.sleep(2000);
            System.out.println(&ldquo;load not exist key from cache : &rdquo; + loadingCache.get(&ldquo;email&rdquo;).orNull());
        } catch (ExecutionException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
{% endraw %}
{% endcodeblock %}
我们逐行进行解释：</p>

<ul>
<li><code>expireAfterWrite(3, TimeUnit.SECONDS)</code>定义缓存3秒过期</li>
<li><code>removalListener</code>用来监听当缓存里面的<code>key</code>被移除时候触发的事件</li>
<li><code>build(new CacheLoader&lt;String, Optional&lt;String&gt;&gt;()</code>传入一个<code>CacheLoader</code>类，指定缓存中没有的时候调用如下方法.</li>
<li><code>Optional</code>当<code>CacheLoader</code>尝试获取数据库中不存在的数据会抛出异常，所以我们这里使用<code>Optional</code>可空对象处理一下。</li>
<li><code>Thread.sleep(2000);</code>缓存我们设置3秒过期，所以两次<code>Sleep</code>以后就会重新获取数据库。
运行输出结果如下，证明了再第三次获取的时候因为缓存过期了，所以需要重新在<code>MockDB</code>获取数据：
<code>sh
load key from persistence : github
load from cache once : codedrinker
load from cache twice : codedrinker
cache expired, remove key : github
load key from persistence : github
load from cache third : codedrinker
load key from persistence : email
load not exist key from cache : null
</code></li>
</ul>


<h2>Callable</h2>

<p>这里我们依然需要使用上面的<code>MockDB</code>类，具体代码如下。
{% codeblock lang:java GuavaCallableCache.java%}
{% raw %}
public class GuavaCallableCache {
    public static void main(String[] args) {
        final String key = &ldquo;github&rdquo;;
        Cache&lt;String, Optional<String>> cache = CacheBuilder.newBuilder()
                .expireAfterWrite(3, TimeUnit.SECONDS)
                .removalListener(new RemovalListener&lt;String, Optional<String>>() {
                    @Override
                    public void onRemoval(RemovalNotification&lt;String, Optional<String>> notification) {
                        System.out.println(&ldquo;cache expired, remove key : &rdquo; + notification.getKey());
                    }
                }).build();
        try {
            Optional<String> optional;
            System.out.println(&ldquo;load from cache once : &rdquo; + cache.get(key, new Callable&lt;Optional<String>>() {
                @Override
                public Optional<String> call() throws Exception {
                    return Optional.fromNullable(MockDB.loadFromPersistence(key));
                }
            }).orNull());
            Thread.sleep(2000);
            System.out.println(&ldquo;load from cache twice : &rdquo; + cache.get(key, new Callable&lt;Optional<String>>() {
                @Override
                public Optional<String> call() throws Exception {
                    return Optional.fromNullable(MockDB.loadFromPersistence(key));
                }
            }).orNull());
            Thread.sleep(2000);
            System.out.println(&ldquo;load from cache third : &rdquo; + cache.get(key, new Callable&lt;Optional<String>>() {
                @Override
                public Optional<String> call() throws Exception {
                    return Optional.fromNullable(MockDB.loadFromPersistence(key));
                }
            }).orNull());
            Thread.sleep(2000);
            final String nullKey = &ldquo;email&rdquo;;
            optional = cache.get(nullKey, new Callable&lt;Optional<String>>() {
                @Override
                public Optional<String> call() throws Exception {
                    return Optional.fromNullable(MockDB.loadFromPersistence(nullKey));
                }
            });
            System.out.println(&ldquo;load not exist key from cache : &rdquo; + optional.orNull());
        } catch (ExecutionException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
{% endraw %}
{% endcodeblock %}
下面我们对程序进行解释，与上面例子唯一的不同就是没有在<code>build</code>的时候传入<code>CacheLoader</code>，而是在<code>cache.get</code>使用<code>Cache</code>的时候用传入<code>Callable</code>对象。这样做可以灵活配置每次获取的缓存源不一样，但是两种方案都各有好处，还是在使用的时候斟酌。
运行程序数据结果如下：
<code>sh
load key from persistence : github
load from cache once : codedrinker
load from cache twice : codedrinker
cache expired, remove key : github
load key from persistence : github
load from cache third : codedrinker
load key from persistence : email
load not exist key from cache : null
</code></p>

<h2>总结</h2>

<p>在设计Java分布式应用程序的时候，针对一些基本不变的数据，或者是变化不大然而使用非常频繁的数据可以考虑采用<code>Guava Cache</code>实现Java应用内存级别缓存。</p>

<h2>参考链接</h2>

<p><a href="https://github.com/google/guava/wiki/CachesExplained">Guava Cache</a></p>
]]></content>
  </entry>
  
</feed>
