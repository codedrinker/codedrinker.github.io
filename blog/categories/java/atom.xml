<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 码匠笔记]]></title>
  <link href="http://www.majiang.life/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://www.majiang.life/"/>
  <updated>2018-07-01T09:03:15+08:00</updated>
  <id>http://www.majiang.life/</id>
  <author>
    <name><![CDATA[麻酱]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[把《阿里巴巴Java开发手册》读薄]]></title>
    <link href="http://www.majiang.life/blog/alibaba-p3c/"/>
    <updated>2018-05-13T14:59:27+08:00</updated>
    <id>http://www.majiang.life/blog/alibaba-p3c</id>
    <content type="html"><![CDATA[<h1>描述</h1>

<p>最近读了一下《阿里巴巴Java开发手册》，下面是一些应该注意问题的整理。其实读这个手册最重要明白了两个问题<br/>
第一点，一个开发团队一定要有一个自己的编程规约。<br/>
第二点，优化是从每一个小的细节入手。</p>

<!-- more -->


<h1>编程命名</h1>

<h2>命名规则</h2>

<p>1.【强制】所有编程相关的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。<br/>
反例：_name / __name / $Object / name_ / name$ / Object$
2.【强制】类名使用UpperCamelCase风格，以下情形例外：DO / BO / DTO / VO / AO<br/>
3.【强制】常量命名应该全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br/>
4.【强制】抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类名开始，以Test结尾。<br/>
5.【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。  <br/>
正例：应用工具类包名为com.alibaba.aone.force.util；类名为MessageUtils（此规则参考spring的框架结构）
6.【强制】杜绝完全不规范的缩写，集团认可的缩写请参考附2。<br/>
反例：&lt;某业务代码>AbstractClass“缩写”命名成AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。<br/>
7.【推荐】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达。<br/>
正例：在JDK中，对某个对象引用的volatile字段进行原子更新的类名为：AtomicReferenceFieldUpdater。
反例：常见的方法内变量为int a; 的定义方式。<br/>
8.【推荐】如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。  <br/>
说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。<br/>
正例：public class OrderFactory;<br/>
    public class LoginProxy;
    public class ResourceObserver;<br/>
9.【参考】枚举类名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。<br/>
说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。<br/>
正例：枚举名字：ProcessStatusEnum；成员名称：SUCCESS / UNKNOWN_REASON。<br/>
10.【参考】各层命名规约： <br/>
A) Service/DAO层方法命名规约<br/>
   1） 获取单个对象的方法用get作前缀。<br/>
   2） 获取多个对象的方法用list作前缀。<br/>
   3） 获取统计值的方法用count作前缀。<br/>
   4） 插入的方法用save/insert作前缀。<br/>
   5） 删除的方法用remove/delete作前缀。<br/>
   6） 修改的方法用update作前缀。</p>

<h2>常量定义</h2>

<p>1.【强制】不允许任何魔法值（即未经预先定义的常量）直接出现在代码中。<br/>
反例：String key = &ldquo;Id#taobao_&rdquo; + tradeId；<br/>
    cache.put(key, value);<br/>
  本例中同学A定义了缓存的key，然后缓存提取的同学B使用了Id#taobao来提取，少了下划线，导致故障。<br/>
2.【强制】long或者Long初始赋值时，使用大写的L，不能是小写的l，小写容易跟数字1混淆，造成误解。<br/>
说明：Long a = 2l; 写的是数字的21，还是Long型的2?<br/>
3.【推荐】不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。<br/>
正例：缓存相关的常量放在类CacheConsts下；系统配置相关的常量放在类ConfigConsts下。<br/>
说明：大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解，也不利于维护。<br/>
4.【推荐】如果变量值仅在一个固定范围内变化用enum类型来定义。<br/>
说明：如果存在名称之外的延伸属性使用enum类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节。<br/>
正例：<br/>
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">enum</span> <span class="n">SeasonEnum</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">SPRING</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="n">SUMMER</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="n">AUTUMN</span><span class="o">(</span><span class="mi">3</span><span class="o">),</span> <span class="n">WINTER</span><span class="o">(</span><span class="mi">4</span><span class="o">);&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kd">private</span> <span class="kt">int</span> <span class="n">seq</span><span class="o">;</span>
</span><span class='line'><span class="n">SeasonEnum</span><span class="o">(</span><span class="kt">int</span> <span class="n">seq</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">this</span><span class="o">.</span><span class="na">seq</span> <span class="o">=</span> <span class="n">seq</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></p>

<h2>格式规约</h2>

<p>1.【强制】注释的双斜线与注释内容之间有且仅有一个空格。<br/>
正例：</p>

<pre><code class="java">// 这是示例注释，请注意在双斜线之后有一个空格
String ygb = new String();
</code></pre>

<p>2.【强制】单行字符数不超过120个，超出则需要换行，换行时遵循如下原则：<br/>
 1） 第二行相对第一行缩进4个空格，从第三行开始，不再继续缩进，参考示例。<br/>
 2） 运算符与下文一起换行。<br/>
 3） 方法调用的点符号与下文一起换行。<br/>
 4） 方法调用中的多个参数需要换行时，在逗号后进行。<br/>
 5） 在括号前不要换行，见反例。<br/>
正例：</p>

<pre><code class="java">StringBuffer sb = new StringBuffer();
// 超过120个字符的情况下，换行缩进4个空格，并且方法前的点号一起换行
sb.append("zi").append("xin")...
    .append("huang")...
    .append("huang")...
    .append("huang");
</code></pre>

<h3>OOP规约</h3>

<p>1.【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。<br/>
2.【强制】不能使用过时的类或方法。<br/>
说明：java.net.URLDecoder 中的方法decode(String encodeStr) 这个方法已经过时，应该使用双参数decode(String source, String encode)  。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。<br/>
3.【强制】Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。<br/>
正例：&#8221;test&#8221;.equals(object);<br/>
反例：object.equals(&ldquo;test&rdquo;);<br/>
说明：推荐使用java.util.Objects#equals （JDK7引入的工具类）<br/>
4.【强制】所有的相同类型的包装类对象之间值的比较，全部使用equals方法比较。<br/>
说明：对于Integer var=?在-128至127之间的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。<br/>
5.关于基本数据类型与包装数据类型的使用标准如下：<br/>
1） 【强制】所有的 POJO 类属性必须使用包装数据类型。<br/>
2） 【强制】RPC 方法的返回值和参数必须使用包装数据类型。<br/>
3） 【推荐】所有的局部变量使用基本数据类型。<br/>
说明：POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE   问题，或者入库检查，都由使用者来保证。正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。反例：比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。<br/>
6.【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。<br/>
反例：POJO 类的 gmtCreate 默认值为 new Date();但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。<br/>
7.【强制】POJO 类必须写 toString 方法。使用 IDE 中的工具：source> generate toString时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。  <br/>
说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。</p>

<h2>集合处理</h2>

<ol>
<li>【强制】关于 hashCode 和 equals 的处理，遵循如下规则：<br/>
1） 只要重写 equals，就必须重写 hashCode。<br/>
2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法。<br/>
3） 如果自定义对象作为 Map 的键，那么必须重写 hashCode 和 equals。<br/>
说明：String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用。</li>
<li>【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一样的数组，大小就是 list.size()。说明：使用 toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配内存空间，并返回新数组地址；如果数组元素个数大于实际所需，下标为[ list.size() ]的数组元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。<br/>
正例：<br/>
<code>java
List list = new ArrayList(2);
list.add("guan");
list.add("bao");
String[] array = new String[list.size()];
array = list.toArray(array);
</code></li>
</ol>


<p>3.【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。<br/>
说明：asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。</p>

<pre><code class="java">String[] str = new String[] { "you", "wu" };
List list = Arrays.asList(str);
</code></pre>

<p>第一种情况：list.add(&ldquo;yangguanbao&rdquo;); 运行时异常。<br/>
第二种情况：str[0] = &ldquo;gujin&rdquo;; 那么 list.get(0)也会随之修改。<br/>
4.【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。<br/>
正例：<br/>
<code>java
Iterator&lt;String&gt; iterator = list.iterator();
while (iterator.hasNext()) {
    String item = iterator.next();
    if (删除元素的条件) {
        iterator.remove();
    }
}
</code></p>

<p>5.【推荐】集合初始化时，指定集合初始值大小。<br/>
说明：HashMap 使用 HashMap(int initialCapacity) 初始化，正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loaderfactor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16（即默认值）。<br/>
反例：HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫扩大，resize 需要重建 hash 表，严重影响性能。<br/>
6.【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。<br/>
说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用 Map.foreach 方法。<br/>
正例：values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是一个 Set 集合对象；entrySet()返回的是 K-V 值组合集合。</p>

<h2>并发处理</h2>

<p>1.【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。<br/>
说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。<br/>
2.【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<br/>
说明：Executors 返回的线程池对象的弊端如下：<br/>
1）FixedThreadPool 和 SingleThreadPool:允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。<br/>
2）CachedThreadPool 和 ScheduledThreadPool:允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。<br/>
3.【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown方法，线程执行代码注意 catch 异常，确保 countDown 方法被执行到，避免主线程无法执行至 await   方法，直到超时才返回结果。说明：注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。<br/>
4.【参考】volatile   解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是 count++操作，使用如下类实现：AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。</p>

<h2>控制语句</h2>

<p>1.【强制】在高并发场景中，避免使用”等于”判断作为中断或退出的条件。<br/>
说明：如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间
判断条件来代替。<br/>
反例：判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变
成了负数，这样的话，活动无法终止。</p>

<h2>注释规约</h2>

<p>1.【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/**内容*/格式，不得使用// xxx 方式。
说明：在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率 。<br/>
2.【强制】所有的类都必须添加创建者和创建日期。<br/>
3.【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。<br/>
4.【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。<br/>
5.【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。<br/>
反例：
<code>c
// put elephant into fridge
put(elephant, fridge);
</code>
方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。</p>

<h1>异常日志</h1>

<p>1.【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。<br/>
说明：本手册明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null 的情况。<br/>
2. 【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：<br/>
1）返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。<br/>
2） 数据库的查询结果可能为 null。<br/>
3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。<br/>
4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。<br/>
5） 对于 Session 中获取的数据，建议 NPE 检查，避免空指针。<br/>
6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。<br/>
正例：使用 JDK8 的 Optional 类来防止 NPE 问题。<br/>
3.【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。<br/>
<code>java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(Abc.class);
</code>
4.【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式。
说明：logger.debug(&ldquo;Processing trade with id: &rdquo; + id + &ldquo; and symbol: &rdquo; + symbol);如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。<br/>
正例：（条件）  <br/>
<code>java
if (logger.isDebugEnabled()) {
logger.debug("Processing trade with id: " + id + " and symbol: " + symbol);
}  
</code>
正例：（占位符）  <br/>
logger.debug(&ldquo;Processing trade with id: {} and symbol : {} &rdquo;, id, symbol);  <br/>
5.【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。<br/>
正例：<logger name="com.taobao.dubbo.config" additivity="false"></p>

<h2>其他</h2>

<p>1.【强制】velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is前缀），会自动调用 isXxx()  方法。说明：注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法。</p>

<h1>安全规约</h1>

<p>1.【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。<br/>
说明：防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信内容、修改他人的订单。<br/>
2.【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。<br/>
说明：个人手机号码显示为:158****9119，隐藏中间 4 位，防止隐私泄露。<br/>
3.【强制】用户请求传入的任何参数必须做有效性验证。<br/>
说明：忽略参数校验可能导致：<br/>
 page size 过大导致内存溢出<br/>
 恶意 order by 导致数据库慢查询<br/>
 任意重定向<br/>
 SQL 注入<br/>
 反序列化注入<br/>
 正则输入源串拒绝服务 ReDoS</p>

<h1>MySQL 数据库</h1>

<h2>建表规约</h2>

<p>1.【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（ 1 表示是，0 表示否）。<br/>
说明：任何字段如果为非负数，必须是 unsigned。<br/>
正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。<br/>
2.【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只
出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。<br/>
说明：MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库<br/>
名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。<br/>
正例：aliyun_admin，rdc_config，level3_name<br/>
反例：AliyunAdmin，rdcConfig，level_3_name<br/>
3.【强制】表名不使用复数名词。 <br/>
说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数
形式，符合表达习惯。<br/>
4.【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。<br/>
5.【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。<br/>
说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。<br/>
6.【强制】小数类型为 decimal，禁止使用 float 和 double。<br/>
说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不
正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。<br/>
7.【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。<br/>
8.【强制】表必备三字段：id, gmt_create, gmt_modified。<br/>
说明：其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。gmt_create,
gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被
动更新。<br/>
9.【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。<br/>
说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。<br/>
10.【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检
索速度。<br/>
正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。<br/>
对象 年龄区间 类型 字节 表示范围<br/>
人 150 岁之内 unsigned tinyint 1 无符号值：0 到 255<br/>
龟 数百岁 unsigned smallint 2 无符号值：0 到 65535<br/>
恐龙化石 数千万年 unsigned int 4 无符号值：0 到约 42.9 亿<br/>
太阳 约 50 亿年 unsigned bigint 8 无符号值：0 到约 10 的 19 次方</p>

<h2>索引规约</h2>

<p>1.【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。<br/>
说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明
显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必
然有脏数据产生。<br/>
2.【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。<br/>
说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索
引。<br/>
3.【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合
索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。<br/>
正例：where a=? and b=? order by c; 索引：a_b_c<br/>
反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a>10 ORDER BY b; 索引
a_b 无法排序。<br/>
4.【推荐】利用延迟关联或者子查询优化超多分页场景。<br/>
说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回
N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过
特定阈值的页数进行 SQL 改写。<br/>
正例：先快速定位需要获取的 id 段，然后再关联：<br/>
 SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id<br/>
5. 【推荐】建组合索引的时候，区分度最高的在最左边。<br/>
正例：如果 where a=? and b=? ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即
可。<br/>
说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a>?
and b=? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。</p>

<h2>SQL 语句</h2>

<p>1.【强制】不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)是 SQL92 定义的
标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。<br/>
说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。<br/>
2.【强制】不得使用外键与级联，一切外键概念必须在应用层解决。<br/>
说明：以学生和成绩的关系为例，学生表中的 student_id是主键，那么成绩表中的 student_id
则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为
级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻
塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。<br/>
3.【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p>

<h2>ORM 映射</h2>

<p>1.【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。
说明：1）增加查询分析器解析成本。2）增减字段容易与 resultMap 配置不一致。<br/>
2.【强制】sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。<br/>
3.【强制】更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。<br/>
4.【推荐】不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字
段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL
时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。</p>

<h1>工程结构</h1>

<p>1.【参考】分层领域模型规约：
 DO（Data Object）：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。<br/>
 DTO（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。<br/>
 BO（Business Object）：业务对象。由 Service 层输出的封装业务逻辑的对象。<br/>
 AO（Application Object）：应用对象。在 Web 层与 Service 层之间抽象的复用对象模型,极为贴近展示层，复用度不高。<br/>
 VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。<br/>
 Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止
使用 Map 类来传输。<br/>
2.【强制】定义 GAV 遵从以下规则：  <br/>
1） GroupID 格式：com.{公司/BU }.业务线.[子业务线]，最多 4 级。<br/>
说明：{公司/BU} 例如：alibaba/taobao/tmall/aliexpress 等 BU 一级；子业务线可选。<br/>
正例：com.taobao.jstorm 或 com.alibaba.dubbo.register<br/>
2） ArtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。<br/>
正例：dubbo-client / fastjson-api / jstorm-tool<br/>
3） Version：详细规定参考下方。<br/>
3.【强制】二方库版本号命名方式：主版本号.次版本号.修订号<br/>
1） 主版本号：产品方向改变，或者大规模 API 不兼容，或者架构不兼容升级。<br/>
2） 次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的 API 不兼容修改。<br/>
3） 修订号：保持完全兼容性，修复 BUG、新增次要功能特性等。<br/>
说明：注意起始版本号必须为：1.0.0，而不是 0.0.1 正式发布的类库必须先去中央仓库进
行查证，使版本号有延续性，正式版本号不允许覆盖升级。如当前版本：1.3.3，那么下一个
合理的版本号：1.3.4 或 1.4.0 或 2.0.0<br/>
4.【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。<br/>
说明：依赖 springframework-core,-context,-beans，它们都是同一个版本，可以定义一
个变量来保存版本：${spring.version}，定义依赖的时候，引用该版本。<br/>
5.【推荐】高并发服务器建议调小 TCP 协议的 time_wait 超时时间。
说明：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服
务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上
调小此等待值。<br/>
正例：在 linux 服务器上请通过变更/etc/sysctl.conf 文件去修改该缺省值（秒）：
net.ipv4.tcp_fin_timeout = 30<br/>
6.【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为 fd）。<br/>
说明：主流操作系统的设计是将 TCP/UDP 连接采用与文件一样的方式去管理，即一个连接对
应于一个 fd。主流的 linux 服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很容易因为 fd 不足而出现“open too many files”错误，导致新的连接无法建立。 建议将 linux
服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。<br/>
7.【推荐】给 JVM 设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出
dump 信息。<br/>
说明：OOM 的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错
非常有价值。<br/>
8.【推荐】在线上生产环境，JVM 的 Xms 和 Xmx 设置一样大小的内存容量，避免在 GC 后调整堆
大小带来的压力。</p>

<p><a href="https://github.com/alibaba/p3c/blob/master/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BA%AA%E5%BF%B5%E7%89%88%EF%BC%89.pdf">阿里巴巴Java开发手册（纪念版）.pdf</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JUC系列:ThreadPoolExecutor]]></title>
    <link href="http://www.majiang.life/blog/juc-threadpoolexecutor/"/>
    <updated>2018-04-28T00:22:21+08:00</updated>
    <id>http://www.majiang.life/blog/juc-threadpoolexecutor</id>
    <content type="html"><![CDATA[<h2>简介</h2>

<p>ThreadPoolExecutor 是 JUC 里面的成员，我们可以使用他轻松的创建线程池。<br/>
当然我们可以自己创建线程，但是有 ThreadPoolExecutor，他的好处还是很多的，比如可以帮我们管理线程，不需要我们手动的关闭线程，同时可以通过各种不同的线程创建和销毁策略应对不同的多线程场景。合理的使用 ThreadPoolExecutor 会让我们的开发效率和性能事半功倍。</p>

<!-- more -->


<h2>使用</h2>

<h3>创建</h3>

<p>我们可以通过ThreadPoolExecutor来创建一个线程池。</p>

<pre><code>new  ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, handler);
</code></pre>

<p>创建一个线程池需要输入几个参数，需要简单的讲解一下。
corePoolSize：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。这个时候新的线程会放到阻塞队列里面。也就是下面的参数。</p>

<p>runnableTaskQueue：阻塞队列有很多种，分别使用不同的场景。
ArrayBlockingQueue</p>

<ul>
<li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</li>
<li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出）排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li>
<li>PriorityBlockingQueue：一个具有优先级得无限阻塞队列。</li>
</ul>


<p>maximumPoolSize：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。</p>

<p>ThreadFactory：用于设置创建线程的工厂，可以创建线程的时候指定名字和一些其他配置，方便记录和调试。</p>

<p>RejectedExecutionHandler：当队列和线程池都满了，这个时候线程池已经出现负载问题，不能处理新的任务了，所以需要一个策略来处理。可选的策略如下，当然我们可以实现RejectedExecutionHandler接口自定义策略。</p>

<ul>
<li>AbortPolicy：直接抛出异常。</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。</li>
</ul>


<p>keepAliveTime：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。减少因频繁创建线程消耗的时间。<br/>
TimeUnit：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。</p>

<h2>使用</h2>

<p>使用方式很简单，有两种方式，一种是直接execute，这样直接可以运营一个 Runnable的类，但是不能获得返回值，另一种方式是使用submit，调用成功以后会获得一个future，这样就可以通过这个future查看当前线程的运行状态。
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TheadPoolTest</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">ThreadPoolExecutor</span> <span class="n">threadPoolExecutor</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">50</span><span class="o">,</span> <span class="mi">60</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">,</span> <span class="k">new</span> <span class="n">LinkedBlockingQueue</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;&amp;</span><span class="n">gt</span><span class="o">;());</span>
</span><span class='line'>    <span class="n">threadPoolExecutor</span><span class="o">.</span><span class="na">execute</span><span class="o">(()</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()));</span>
</span><span class='line'>    <span class="n">Future</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">threadPoolExecutor</span><span class="o">.</span><span class="na">submit</span><span class="o">(()</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()));</span>
</span><span class='line'>    <span class="k">while</span> <span class="o">(!</span><span class="n">future</span><span class="o">.</span><span class="na">isDone</span><span class="o">()){</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Doing&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">future</span><span class="o">.</span><span class="na">isDone</span><span class="o">());</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></p>

<h2>配置</h2>

<p>主要的配置参数就是coreSize了，其他的参数主要还是在配置coreSize使用。通常情况下任务分为CPU密集型任务和IO密集型任务
CPU密集型任务配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池，可以使用Executors.newFixedThreadPool()创建。
IO密集型任务则由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。混合型的任务，可以使用 Executors.newCachedThreadPool 创建。</p>

<h2>关闭</h2>

<h3>shutdown</h3>

<p>将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p>

<h3>shutdownNow</h3>

<p>遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p>

<p>当调用上述任何一个方式，isShutdown方法就会返回true。当所有任务直接完成以后，isTermined方法会返回true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[细说 Java hashCode]]></title>
    <link href="http://www.majiang.life/blog/deep-dive-on-java-hashcode/"/>
    <updated>2017-12-24T01:04:24+08:00</updated>
    <id>http://www.majiang.life/blog/deep-dive-on-java-hashcode</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>写过 <code>Java</code> 程序的同学一定都知道 <code>hashCode</code> 方法，它是 <code>Object</code> 对象的一个 <code>native</code> 方法。无论是我们平常使用的 <code>HashMap</code> 还是重写 <code>equals</code> 方法的时候，都会接触到 <code>hashCode</code> 方法，那么它究竟是怎么生成的，又有什么作用呢？笔者带着这个疑问开始探寻。</p>

<!-- more -->


<h2>hashCode 方法的定义</h2>

<p>在 <a href="https://docs.oracle.com/javase/7/docs/api/"><code>jdk api</code></a> 中 关于 <code>hashCode</code> 有如下说明：</p>

<pre><code class="sh">Returns a hash code value for the object. 
This method is supported for the benefit of hash tables such as those provided by HashMap.
The general contract of hashCode is:

Whenever it is invoked on the same object more than once during an execution of a Java application, 
the hashCode method must consistently return the same integer, 
provided no information used in equals comparisons on the object is modified. 
This integer need not remain consistent from one execution of an application to another execution of the same application.
If two objects are equal according to the equals(Object) method, 
then calling the hashCode method on each of the two objects must produce the same integer result.
It is not required that if two objects are unequal according to the equals(java.lang.Object) method, 
then calling the hashCode method on each of the two objects must produce distinct integer results. 
However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.
As much as is reasonably practical, 
the hashCode method defined by class Object does return distinct integers for distinct objects. 
(This is typically implemented by converting the internal address of the object into an integer, 
    but this implementation technique is not required by the JavaTM programming language.)
</code></pre>

<p>其大致意思如下</p>

<pre><code class="sh">只要在Java应用程序的执行过程中多次调用同一个对象，
hashCode方法必须始终返回相同的整数，
前提是在对象的equals比较中没有使用的信息被修改。  
从应用程序的一次执行到同一应用程序的另一次执行，此整数不必保持一致。  

如果两个对象按照equals（Object）方法相等，
那么在两个对象的每一个上调用hashCode方法必须产生相同的整数结果。  
如果两个对象根据equals（java.lang.Object）方法不相等，
则不要求对两个对象中的每个对象调用hashCode方法都必须产生不同的整数结果。  
但是，程序员应该知道，为不相等的对象生成不同的整数结果可以提高散列表的性能。  

尽可能多地合理实用，由类Object定义的hashCode方法确实为不同的对象返回不同的整数。  
这通常通过将对象的内部地址转换为整数来实现，但JavaTM编程语言不需要此实现技术。 
</code></pre>

<p>所以由上可以得到两条有用的信息，同一个对象 <code>hashcode</code> 的值在一次运行中一定相等，并且不同对象的 <code>hashcode</code> 一定不同，但是他还备注通常使用内部地址转换，但是 <code>JAVA</code> 不是使用这种方式实现的，那么怎么实现的呢？</p>

<h2>hashCode 实现原理</h2>

<h3>hashcode 源码</h3>

<p><code>OpenJDK</code> 的源码可以直接查看，所以我们就选择查看一下其源码一看究竟。<br/>
我们可以看到<code>src/share/vm/prims/jvm.h</code>和<code>src/share/vm/prims/jvm.cpp</code>两个文件中有关于 <code>hashcode</code> 的说明如下：
<code>
   JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))
   JVMWrapper("JVM_IHashCode");
   // as implemented in the classic virtual machine; return 0 if object is NULL
   return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;
 JVM_END
</code>
我们继续进入<code>FashHashCode</code>里面查看，其位于<code>src/share/vm/runtime/synchronizer.cpp</code>文件，相对代码比较多，我们只摘取关键部分：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>  <span class="c1">// Inflate the monitor to set hash code</span>
</span><span class='line'>  <span class="n">monitor</span> <span class="o">=</span> <span class="n">ObjectSynchronizer</span><span class="o">::</span><span class="n">inflate</span><span class="p">(</span><span class="n">Self</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">// Load displaced header and check it has hash code</span>
</span><span class='line'>  <span class="n">mark</span> <span class="o">=</span> <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">();</span>
</span><span class='line'>  <span class="n">assert</span> <span class="p">(</span><span class="n">mark</span><span class="o">-&gt;</span><span class="n">is_neutral</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">invariant</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;)</span> <span class="p">;</span>
</span><span class='line'>  <span class="n">hash</span> <span class="o">=</span> <span class="n">mark</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">();</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">hash</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">hash</span> <span class="o">=</span> <span class="n">get_next_hash</span><span class="p">(</span><span class="n">Self</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'>    <span class="n">temp</span> <span class="o">=</span> <span class="n">mark</span><span class="o">-&gt;</span><span class="n">copy_set_hash</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span> <span class="c1">// merge hash code into header</span>
</span><span class='line'>    <span class="n">assert</span> <span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">is_neutral</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">invariant</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;)</span> <span class="p">;</span>
</span><span class='line'>    <span class="n">test</span> <span class="o">=</span> <span class="p">(</span><span class="n">markOop</span><span class="p">)</span> <span class="n">Atomic</span><span class="o">::</span><span class="n">cmpxchg_ptr</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">monitor</span><span class="p">,</span> <span class="n">mark</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">test</span> <span class="o">!=</span> <span class="n">mark</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// The only update to the header in the monitor (outside GC)</span>
</span><span class='line'>      <span class="c1">// is install the hash code. If someone add new usage of</span>
</span><span class='line'>      <span class="c1">// displaced header, please update this code</span>
</span><span class='line'>      <span class="n">hash</span> <span class="o">=</span> <span class="n">test</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">();</span>
</span><span class='line'>      <span class="n">assert</span> <span class="p">(</span><span class="n">test</span><span class="o">-&gt;</span><span class="n">is_neutral</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">invariant</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;)</span> <span class="p">;</span>
</span><span class='line'>      <span class="n">assert</span> <span class="p">(</span><span class="n">hash</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Trivial</span> <span class="n">unexpected</span> <span class="n">object</span><span class="o">/</span><span class="n">monitor</span> <span class="n">header</span> <span class="n">usage</span><span class="p">.</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// We finally get the hash</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">hash</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>
<code>monitor</code> 相关代码我们先略过不理，通过 <code>if</code> 语句我们可以看出，当 <code>hash</code>为0时候需要调用 <code>get_next_hash</code> 生成一个新的 <code>hash</code>，那么我们便可以继续前行。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">intptr_t</span> <span class="nf">get_next_hash</span><span class="p">(</span><span class="n">Thread</span> <span class="o">*</span> <span class="n">Self</span><span class="p">,</span> <span class="n">oop</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">intptr_t</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">hashCode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="c1">// This form uses an unguarded global Park-Miller RNG,</span>
</span><span class='line'>     <span class="c1">// so it&amp;rsquo;s possible for two threads to race and generate the same RNG.</span>
</span><span class='line'>     <span class="c1">// On MP system we&amp;rsquo;ll have lots of RW access to a global, so the</span>
</span><span class='line'>     <span class="c1">// mechanism induces lots of coherency traffic.</span>
</span><span class='line'>     <span class="n">value</span> <span class="o">=</span> <span class="n">os</span><span class="o">::</span><span class="n">random</span><span class="p">()</span> <span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">hashCode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="c1">// This variation has the property of being stable (idempotent)</span>
</span><span class='line'>     <span class="c1">// between STW operations.  This can be useful in some of the 1-0</span>
</span><span class='line'>     <span class="c1">// synchronization schemes.</span>
</span><span class='line'>     <span class="kt">intptr_t</span> <span class="n">addrBits</span> <span class="o">=</span> <span class="n">cast_from_oop</span><span class="o">&lt;</span><span class="kt">intptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span> <span class="p">;</span>
</span><span class='line'>     <span class="n">value</span> <span class="o">=</span> <span class="n">addrBits</span> <span class="o">^</span> <span class="p">(</span><span class="n">addrBits</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">^</span> <span class="n">GVars</span><span class="p">.</span><span class="n">stwRandom</span> <span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">hashCode</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span>            <span class="c1">// for sensitivity testing</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">hashCode</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="n">value</span> <span class="o">=</span> <span class="o">++</span><span class="n">GVars</span><span class="p">.</span><span class="n">hcSequence</span> <span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">hashCode</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="n">value</span> <span class="o">=</span> <span class="n">cast_from_oop</span><span class="o">&lt;</span><span class="kt">intptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>     <span class="c1">// Marsaglia&amp;rsquo;s xor-shift scheme with thread-specific state</span>
</span><span class='line'>     <span class="c1">// This is probably the best overall implementation &amp;ndash; we&amp;rsquo;ll</span>
</span><span class='line'>     <span class="c1">// likely make this the default in future releases.</span>
</span><span class='line'>     <span class="kt">unsigned</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Self</span><span class="o">-&gt;&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">hashStateX</span> <span class="p">;</span>
</span><span class='line'>     <span class="n">t</span> <span class="o">^=</span> <span class="p">(</span><span class="n">t</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">11</span><span class="p">)</span> <span class="p">;</span>
</span><span class='line'>     <span class="n">Self</span><span class="o">-&gt;&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">hashStateX</span> <span class="o">=</span> <span class="n">Self</span><span class="o">-&gt;&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">hashStateY</span> <span class="p">;</span>
</span><span class='line'>     <span class="n">Self</span><span class="o">-&gt;&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">hashStateY</span> <span class="o">=</span> <span class="n">Self</span><span class="o">-&gt;&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">hashStateZ</span> <span class="p">;</span>
</span><span class='line'>     <span class="n">Self</span><span class="o">-&gt;&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">hashStateZ</span> <span class="o">=</span> <span class="n">Self</span><span class="o">-&gt;&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">hashStateW</span> <span class="p">;</span>
</span><span class='line'>     <span class="kt">unsigned</span> <span class="n">v</span> <span class="o">=</span> <span class="n">Self</span><span class="o">-&gt;&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">hashStateW</span> <span class="p">;</span>
</span><span class='line'>     <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="o">^</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">19</span><span class="p">))</span> <span class="o">^</span> <span class="p">(</span><span class="n">t</span> <span class="o">^</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">))</span> <span class="p">;</span>
</span><span class='line'>     <span class="n">Self</span><span class="o">-&gt;</span><span class="n">_hashStateW</span> <span class="o">=</span> <span class="n">v</span> <span class="p">;</span>
</span><span class='line'>     <span class="n">value</span> <span class="o">=</span> <span class="n">v</span> <span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">value</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">=</span> <span class="n">markOopDesc</span><span class="o">::</span><span class="n">hash_mask</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">value</span> <span class="o">=</span> <span class="mh">0xBAD</span> <span class="p">;</span>
</span><span class='line'>  <span class="n">assert</span> <span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="n">markOopDesc</span><span class="o">::</span><span class="n">no_hash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">invariant</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;)</span> <span class="p">;</span>
</span><span class='line'>  <span class="n">TEVENT</span> <span class="p">(</span><span class="nl">hashCode</span><span class="p">:</span> <span class="n">GENERATE</span><span class="p">)</span> <span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
通过上述代码我们看到，其实 <code>hashCode</code> 的生成有6中方式<br/>
1. 随机数<br/>
2. 对象的内存地址的函数<br/>
3. 固定值，这个只是为了进行灵敏度测试<br/>
4. 递增序列<br/>
5. int类型的该对象的内存地址 <br/>
6. 结合当前线程和xorshift生成</p>

<p>通过 <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/globals.hpp#l1127">globals.hpp</a> 我们可以发现，JDK8 默认为5，也就是最后一种。<br/>
<code>product(intx, hashCode, 5, "(Unstable) select hashCode generation algorithm")</code>  <br/>
当然，OpenJDK6，7中用的都是第一种方案，那么问题又来了，既然都是随机数，那么怎么确保每次都一样的呢？</p>

<h3>对象头</h3>

<p>这里就需要引入一个<code>对象头</code>的概念，每次对象生成以后，都需要找一个地方存储一下这个对象的hashCode和锁信息，这就是<code>对象头</code>，英文称之为 <code>Mark Word</code>。这样一来我们就明白了，每次生成对象以后都会把它的<code>hashCode</code>存起来，这样无论对象怎么在新生代，老年代之间<code>游走</code>都不会改变其<code>hashCode</code>的值，然而事实并没有那么简单。</p>

<h3>偏向锁</h3>

<p>这时候我们翻回来看刚才略过的内容，<code>ObjectSynchronizer::FastHashCode()</code>里面的其他逻辑。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">UseBiasedLocking</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// NOTE: many places throughout the JVM do not expect a safepoint</span>
</span><span class='line'>    <span class="c1">// to be taken here, in particular most operations on perm gen</span>
</span><span class='line'>    <span class="c1">// objects. However, we only ever bias Java instances and all of</span>
</span><span class='line'>    <span class="c1">// the call sites of identity_hash that might revoke biases have</span>
</span><span class='line'>    <span class="c1">// been checked to make sure they can handle a safepoint. The</span>
</span><span class='line'>    <span class="c1">// added check of the bias pattern is to avoid useless calls to</span>
</span><span class='line'>    <span class="c1">// thread-local storage.</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">mark</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">has_bias_pattern</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// Box and unbox the raw reference just in case we cause a STW safepoint.</span>
</span><span class='line'>      <span class="n">Handle</span> <span class="n">hobj</span> <span class="p">(</span><span class="n">Self</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="p">;</span>
</span><span class='line'>      <span class="c1">// Relaxing assertion for bug 6320749.</span>
</span><span class='line'>      <span class="n">assert</span> <span class="p">(</span><span class="n">Universe</span><span class="o">::</span><span class="n">verify_in_progress</span><span class="p">()</span> <span class="o">||</span>
</span><span class='line'>              <span class="o">!</span><span class="n">SafepointSynchronize</span><span class="o">::</span><span class="n">is_at_safepoint</span><span class="p">(),</span>
</span><span class='line'>             <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">biases</span> <span class="n">should</span> <span class="n">not</span> <span class="n">be</span> <span class="n">seen</span> <span class="n">by</span> <span class="n">VM</span> <span class="kr">thread</span> <span class="n">here</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
</span><span class='line'>      <span class="n">BiasedLocking</span><span class="o">::</span><span class="n">revoke_and_rebias</span><span class="p">(</span><span class="n">hobj</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">JavaThread</span><span class="o">::</span><span class="n">current</span><span class="p">());</span>
</span><span class='line'>      <span class="n">obj</span> <span class="o">=</span> <span class="n">hobj</span><span class="p">()</span> <span class="p">;</span>
</span><span class='line'>      <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">mark</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">has_bias_pattern</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">biases</span> <span class="n">should</span> <span class="n">be</span> <span class="n">revoked</span> <span class="n">by</span> <span class="n">now</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
由上述代码我们可以得知，当前对象处于<code>偏向锁</code>时，会清除<code>偏向锁</code>通过从<code>锁</code>上面取回<code>Mark Word</code> 信息。为什么提到取回呢？之前消失了吗？是的，现在就需要解释一下<code>偏向锁</code>了。<br/>
<code>Hotspot</code> 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入
了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 <code>ID</code>，以后该线程在进入和退出同步块时不需要花费 <code>CAS</code> 操作来加锁和解锁，而只需简单的测试一下对象头的 <code>Mark Word</code> 里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下 <code>Mark Word</code> 中偏向锁的标识是否设置成 1（表示当前是偏向锁），如果没有设置，则使用 <code>CAS</code> 竞争锁，如果设置了，则尝试使用 <code>CAS</code> 将对象头的偏向锁指向当前线程。所以我们便知道为什么有<code>取回</code>这个概念了。然而代码带没有结束。</p>

<h3>轻量级锁</h3>

<p>轻量级锁相对比较简单，<code>JVM</code>会在当前的线程栈桢中创建用于存放锁的空间，同时将对象头中的<code>Mark Word</code>复制到锁记录中，也称作 <code>Displaced Mark Word</code>。比较复杂的是<code>重量级</code>锁。</p>

<h3>重量级锁</h3>

<p>这个时候如果多个线程来竞争资源，就会发生<code>锁膨胀</code>，这样因为需要保存竞争资源需要<code>wait</code>的线程和相关信息，就引入了<code>monitor</code>的概念。于是这时候就把<code>Mark Word</code>存放到了<code>Monitor</code>里面，当然<code>Monitor</code>不仅仅用于存储对象的<code>Mark Word</code>，具体的作用就不是本文的重点了。</p>

<h2>hashCode 的用途</h2>

<p><code>hashCode</code> 的唯一性决定了他可以用来生成<code>HashMap</code>的key，同时也能判断对象是否为同一个对象。另外我们再重写他的时候要多加注意，因为<code>JVM</code>会根据它做一些性能优化。</p>

<h2>总结</h2>

<p>此文为笔者学习 <code>hashCode</code> 的笔记，如有问题欢迎指正。</p>

<h2>参考文献</h2>

<p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm">OpenJDK 源码</a><br/>
<a href="https://docs.oracle.com/javase/7/docs/api/">Oracle JDK Docs</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过 Spring 集成 MyBatis 源码理解 Java动态代理]]></title>
    <link href="http://www.majiang.life/blog/spring-mybatis-and-dynamic-proxy/"/>
    <updated>2017-10-15T21:10:30+08:00</updated>
    <id>http://www.majiang.life/blog/spring-mybatis-and-dynamic-proxy</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>因为 <code>MyBatis</code> 的易上手性和可控性，使得它成为了<code>ORM</code>框架中的首选。近日新起了一个项目，所以重新搭建了一下 <code>Spring-mybatis</code>, 下面是搭建笔记和从<code>Spring-mybatis</code>源码分析其如何使用<code>Java动态代理</code>，希望对大家有帮助。</p>

<!-- more -->


<h2>Spring 集成 Mybatis</h2>

<p><code>Spring</code> 集成 <code>Mybatis</code>的方式有很多种，大家耳熟能详的<code>xml</code>配置方式或者本文的采用的方式：<br/>
首先需要添加<code>MyBatis</code>的和<code>MyBatis-Spring</code>的依赖，本文使用的<code>Spring-mybatis</code>版本是1.3.1。在<code>mvnrepository</code>里面我们可以找到当前<code>Spring-mybatis</code>依赖的<code>spring</code>和<code>mybatis</code>版本，最好是选择匹配的版本以避免处理不必要的兼容性问题。因为<code>MyBatis-Spring</code>中对<code>mybatis</code>的依赖选择了<code>provided</code>模式，所以我们不得不额外添加<code>mybatis</code>依赖，依赖配置如下。
<code>xml pom.xml
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;1.3.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
      &lt;version&gt;3.4.1&lt;/version&gt;
&lt;/dependency&gt;
</code>
接下来会我们要创建工厂bean,放置下面的代码在 Spring 的 XML 配置文件中:<br/>
<code>xml applicationContext.xml
&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;
  &lt;property name="dataSource" ref="dataSource" /&gt;
&lt;/bean&gt;
</code><br/>
这个工厂需要一个<code>DataSource</code>，就是我们熟知的数据源了。这里我们选择了阿里的<code>Druid</code>，同样我们需要引入两个配置
<code>xml pom.xml
&lt;dependency&gt;
 &lt;groupId&gt;mysql&lt;/groupId&gt;
 &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
 &lt;version&gt;5.1.41&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
 &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
 &lt;artifactId&gt;druid&lt;/artifactId&gt;
 &lt;version&gt;1.1.2&lt;/version&gt;
&lt;/dependency&gt;
</code>          <br/>
添加<code>Spring</code>配置如下
<code>xml applicationContext.xml
&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt;
        &lt;!-- 基本属性 url、user、password --&gt;
        &lt;property name="url"&gt;
            &lt;value&gt;&lt;![CDATA[${db.url}]]&gt;&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="username" value="${db.username}"/&gt;
        &lt;property name="password" value="${db.password}"/&gt;       
        &lt;!-- 省略其他配置 --&gt;   
&lt;/bean&gt;
</code>
接下来我们要编写数据库访问对象，大多数人会把它叫做<code>DAO</code>或者<code>Repository</code>，在这里其被称为<code>Mapper</code>，也是因为它的实现方式所决定。要注意的是所指定的映射器类必须是一个接口，而不是具体的实现类。这便因为<code>Mybatis</code>的内部实现使用的是<code>Java动态代理</code>，而<code>Java动态代理</code>只支持接口，关于<code>动态代理</code>我们下文有更详细的描述。
<code>java UserMapper.java
public interface UserMapper {
  @Select("SELECT * FROM users WHERE id = #{userId}")
  User getUser(@Param("userId") String userId);
}
</code>
接下来可以使用 <code>MapperFactoryBean</code>,像下面这样来把接口加入到 <code>Spring</code> 中，这样就把 <code>UserMapper</code> 和 <code>SessionFactory</code>关联到一起了，原来使用<code>xml</code>配置的时候还需要Dao继承<code>SqlSessionDaoSupport</code>才能注入<code>SessionFactory</code>，这种方式直接通过<code>Java动态代理</code>把<code>SqlSessionFactory</code>代理给了<code>UserMapper</code>，使得我们直接使用<code>UserMapper</code>即可。配置如下。
<code>xml applicationContext.xml
&lt;bean id="userMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt;
  &lt;property name="mapperInterface" value="org.mybatis.spring.sample.mapper.UserMapper" /&gt;
  &lt;property name="sqlSessionFactory" ref="sqlSessionFactory" /&gt;
&lt;/bean&gt;
</code>
这样我们已经完成了90%，就差调用了，前提是你<code>Spring</code>环境是OK的。调用 <code>MyBatis</code> 数据方法现在只需一行代码:
<figure class='code'><figcaption><span>FooServiceImpl.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FooServiceImpl</span> <span class="kd">implements</span> <span class="n">FooService</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kd">private</span> <span class="n">UserMapper</span> <span class="n">userMapper</span><span class="o">;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUserMapper</span><span class="o">(</span><span class="n">UserMapper</span> <span class="n">userMapper</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">this</span><span class="o">.</span><span class="na">userMapper</span> <span class="o">=</span> <span class="n">userMapper</span><span class="o">;</span>
</span><span class='line'><span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kd">public</span> <span class="n">User</span> <span class="nf">doSomeBusinessStuff</span><span class="o">(</span><span class="n">String</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">userMapper</span><span class="o">.</span><span class="na">getUser</span><span class="o">(</span><span class="n">userId</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">那么问题又来了</span><span class="err">，</span><span class="n">每次写一个DAO都需要为其写一个</span><span class="err">`</span><span class="n">Bean</span><span class="err">`</span><span class="n">配置</span><span class="err">，</span><span class="n">那不是累死</span><span class="err">？</span><span class="n">于是我们又寻找另一种方案</span><span class="err">，</span><span class="n">代替手动声明</span><span class="err">`</span><span class="o">*</span><span class="n">Mapper</span><span class="err">`。`</span><span class="n">MapperScannerConfigurer</span><span class="err">`</span><span class="n">的出现解决了这个问题</span><span class="err">，</span> <span class="n">它会根据你配置的包路径自动的扫描类文件并自动将它们创建成</span><span class="err">`</span><span class="n">MapperFactoryBean</span><span class="err">`，</span><span class="n">可以在</span> <span class="n">Spring</span> <span class="nl">的配置中添加如下代码:</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">xml</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">xml</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">bean</span> <span class="n">class</span><span class="o">=</span><span class="s">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">property</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;basePackage&quot;</span> <span class="n">value</span><span class="o">=</span><span class="s">&quot;com.github.codedrinker.mapper&quot;</span> <span class="o">/&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">bean</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="err">`</span><span class="n">basePackage</span><span class="err">`</span><span class="n">属性是让你为映射器接口文件设置基本的包路径</span><span class="err">。</span><span class="n">你可以使用分号或逗号作为分隔符设置多于一个的包路径</span><span class="err">。</span><span class="n">这个时候如果想自定义</span><span class="err">`</span><span class="n">sqlSessionFactory</span><span class="err">`</span><span class="n">可以添加如下配置</span><span class="err">：</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">xml</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">xml</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">property</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="n">value</span><span class="o">=</span><span class="s">&quot;sqlSessionFactory&quot;</span> <span class="o">/&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="err">``</span>
</span><span class='line'><span class="n">这样以后还有一点点小瑕疵</span><span class="err">，</span><span class="n">如果我们数据的</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">column</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">名字是</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">_</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">连接的</span><span class="err">，</span><span class="n">那么它不会那么聪明自动转换为驼峰的变量</span><span class="err">，</span><span class="n">所以我们需要对</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">SqlSessionFactoryBean</span><span class="err">`</span><span class="n">做如下配置</span><span class="err">，</span><span class="n">但是在1</span><span class="o">.</span><span class="mf">3.0</span><span class="n">以后才可以通过xml配置</span><span class="err">，</span><span class="n">如果用早起版本的需要注意了</span><span class="err">。</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span> <span class="n">class</span><span class="o">=</span><span class="s">&quot;xml applicationContext.xml&quot;</span><span class="o">&gt;&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">bean</span> <span class="n">id</span><span class="o">=</span><span class="s">&quot;sqlSessionFactory&quot;</span> <span class="n">class</span><span class="o">=</span><span class="s">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>  <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">property</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;dataSource&quot;</span> <span class="n">ref</span><span class="o">=</span><span class="s">&quot;dataSource&quot;</span> <span class="o">/&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>  <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">property</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;configuration&quot;</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>    <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">bean</span> <span class="n">class</span><span class="o">=</span><span class="s">&quot;org.apache.ibatis.session.Configuration&quot;</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>      <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">property</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="n">value</span><span class="o">=</span><span class="s">&quot;true&quot;</span><span class="o">/&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>    <span class="o">&amp;</span><span class="n">lt</span><span class="o">;/</span><span class="n">bean</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>  <span class="o">&amp;</span><span class="n">lt</span><span class="o">;/</span><span class="n">property</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="o">;/</span><span class="n">bean</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">至此关于</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Spring</span> <span class="n">MyBatis</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">的配置已经全部结束</span><span class="err">，</span><span class="n">后面我们会简单说下</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Spring</span> <span class="n">MyBatis</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">中的动态代理</span><span class="err">。</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h2</span><span class="o">&gt;</span><span class="n">浅析</span> <span class="n">Java</span> <span class="n">动态代理</span><span class="o">&lt;/</span><span class="n">h2</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">JDK</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">自带的动态代理需要了解InvocationHandler接口和Proxy类</span><span class="err">，</span><span class="n">他们都是在java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">reflect包下</span><span class="err">。</span><span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">InvocationHandler</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">是代理实例的调用处理程序实现的接口</span><span class="err">。</span><span class="n">每个代理实例都具有一个关联的</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">InvocationHandler</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">。</span><span class="n">对代理实例调用方法时</span><span class="err">，</span><span class="n">这个方法会调用</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">InvocationHandler</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">的</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">invoke</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">方法</span><span class="err">。</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Proxy</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">提供静态方法用于创建动态代理类和实例</span><span class="o">,</span><span class="n">同时后面自动生成的代理类都是</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Proxy</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">对象</span><span class="err">。</span><span class="n">下面我们直接通过代码来分析</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Java动态代理</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">：</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">InvocationInterceptor</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">实现</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">InvocationHandler</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">接口</span><span class="err">，</span><span class="n">用于处理具体的代理逻辑</span><span class="err">。</span>
</span></code></pre></td></tr></table></div></figure>java InvocationInterceptor.java
/<em>*
 * Created by codedrinker on 12/10/2017.
 </em>/
public class InvocationInterceptor implements InvocationHandler {
    private Object target;</p>

<pre><code>public InvocationInterceptor(Object target) {
    this.target = target;
}
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    System.out.println("before user create");
    method.invoke(target, args);
    System.out.println("end user create");
    return null;
}
</code></pre>

<p>}
<code>
`User`和`UserImpl`是被代理对象的接口和类
</code>java User.java
/<em>*
 * Created by codedrinker on 12/10/2017.
 </em>/
public interface User {
    void create();
}</p>

<p><code>
</code>java UserImpl.java
/<strong>
 * Created by codedrinker on 12/10/2017.
 */
public class UserImpl implements User {
    @Override
    public void create() {
        System.out.println(&ldquo;create user&rdquo;);
    }
}
<code>
`DynamicProxyTest`是测试类，用于创建`InvocationInterceptor`和`Proxy`类以便测试。
</code>java DynamicProxyTest.java
/</strong>
 * Created by codedrinker on 12/10/2017.
 <em>/
public class DynamicProxyTest {
    public static void main(String[] args) {
        User target = new UserImpl();
        InvocationInterceptor invocationInterceptor = new InvocationInterceptor(target);
        User proxyInstance = (User) Proxy.newProxyInstance(UserImpl.class.getClassLoader(),
                UserImpl.class.getInterfaces(),
                invocationInterceptor);
        proxyInstance.create();
    }
}
<code>
输入结果如下：
</code>sh
before user create
create user
end user create
<code>
很明显，我们通过proxyInstance这个代理类进行方法调用的时候，会在方法调用前后进行输出打印，这样就简单的实现了一个`Java动态代理`例子。动态代理不仅仅是打印输出这么简单，我们可以通过它打印日志，打开关闭事务， 权限检查了等等。当然它更是许多框架的钟爱，就如下文我们要说的`MyBatis`中`Java动态代理`的实现。再多说一句`Spring`的`AOP`也是使用动态代理实现的，当然它同时使用了`Java动态代理`和`CGLib`两种方式。不过`CGLIB`不是本文要讨论的范围。  
注意观察的同学看到上面代码的时候可能发现`invoke`方法的`proxy`参数并没有被使用，笔者查阅了一些相关文档也没有找到合理的说法，只能在源码中看看究竟喽，笔者当前的JDK版本是1.8。我们从入口开始，`Proxy.newProxyInstance`:
</code>java Proxy.java片段
/</em>
 * Look up or generate the designated proxy class.
 */
@CallerSensitive
public static Object newProxyInstance(ClassLoader loader,
                                      Class&lt;?>[] interfaces,
                                      InvocationHandler h)
    throws IllegalArgumentException
{
    Class&lt;?> cl = getProxyClass0(loader, intfs);
}
<code>
如上代码由此可见，它调用了`getProxyClass0`来获取`Proxy Class`，那我们继续往下看。
</code>java Proxy.java片段
private static Class&lt;?> getProxyClass0(ClassLoader loader,
                                           Class&lt;?>&hellip; interfaces) {
    if (interfaces.length > 65535) {
        throw new IllegalArgumentException(&ldquo;interface limit exceeded&rdquo;);
    }
    //If the proxy class defined by the given loader implementing
    //the given interfaces exists, this will simply return the cached copy;
    //otherwise, it will create the proxy class via the ProxyClassFactory
    return proxyClassCache.get(loader, interfaces);
}
<code>
其实上面写的已经很简单了，如果存在就在`proxyClassCache`里面获取到，如果不存在就使用`ProxyClassFactory`创建一个。当然我们如果看一下`proxyClassCache`变量的话其也是`ProxyClassFactory`对象。
</code>java
   private static final WeakCache&lt;ClassLoader, Class&lt;?>[], Class&lt;?>>
        proxyClassCache = new WeakCache&lt;>(new KeyFactory(), new ProxyClassFactory());
<code>
那么我们直接就去查看`ProxyClassFactory`的实现问题不就解决了吗？
</code>java Proxy.java片段
    private static final class ProxyClassFactory
        implements BiFunction&lt;ClassLoader, Class&lt;?>[], Class&lt;?>>
    {
        // prefix for all proxy class names
        private static final String proxyClassNamePrefix = &ldquo;$Proxy&rdquo;;
        //next number to use for generation of unique proxy class names
        private static final AtomicLong nextUniqueNumber = new AtomicLong();
        @Override
        public Class&lt;?> apply(ClassLoader loader, Class&lt;?>[] interfaces) {</p>

<pre><code>        String proxyName = proxyPkg + proxyClassNamePrefix + num;
        /*
         * Generate the specified proxy class.
         */
        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
            proxyName, interfaces, accessFlags);
    }
}
</code></pre>

<pre><code>由上代码便一目了然了，为什么我们`Debug`的时候`Proxy`对象是`$Proxy0`，是因为他通过`$Proxy`和`AtomicLong`拼起来的类名，其实这不是重点。重点是`ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags)`。这就是生成`class`的地方，它把所有的条件组合好，生成`class`文件，然后再加载到内存里面以供使用。有兴趣的同学可以继续往深处查看。而我们需要做的是获取到他生成的字节码，看一下里面到底是什么？当`saveGeneratedFiles`为`true`的时候会保存`class`文件，所以我们在`DynamicProxyTest`的`main`函数添加一行即可：
</code></pre>

<p>System.setProperty(&ldquo;sun.misc.ProxyGenerator.saveGeneratedFiles&rdquo;, &ldquo;true&rdquo;);
<code>
通过`Debug`我们可以发现，它存储`class`文件的路径是`com/sun/proxy/$Proxy0.class`，所以直接在我们项目的目录下面就能找到它，然后通过`Idea`打开便得到如下代码：
</code>java $Proxy0.class
public final class $Proxy0 extends Proxy implements User {
    private static Method m1;
    private static Method m2;
    private static Method m3;
    private static Method m0;</p>

<pre><code>public $Proxy0(InvocationHandler var1) throws  {
    super(var1);
}

public final boolean equals(Object var1) throws  {
    try {
        return ((Boolean)super.h.invoke(this, m1, new Object[]{var1})).booleanValue();
    } catch (RuntimeException | Error var3) {
        throw var3;
    } catch (Throwable var4) {
        throw new UndeclaredThrowableException(var4);
    }
}

public final String toString() throws  {
    try {
        return (String)super.h.invoke(this, m2, (Object[])null);
    } catch (RuntimeException | Error var2) {
        throw var2;
    } catch (Throwable var3) {
        throw new UndeclaredThrowableException(var3);
    }
}

public final void create() throws  {
    try {
        super.h.invoke(this, m3, (Object[])null);
    } catch (RuntimeException | Error var2) {
        throw var2;
    } catch (Throwable var3) {
        throw new UndeclaredThrowableException(var3);
    }
}

public final int hashCode() throws  {
    try {
        return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();
    } catch (RuntimeException | Error var2) {
        throw var2;
    } catch (Throwable var3) {
        throw new UndeclaredThrowableException(var3);
    }
}

static {
    try {
        m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[]{Class.forName("java.lang.Object")});
        m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]);
        m3 = Class.forName("local.dynimicproxy.User").getMethod("create", new Class[0]);
        m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);
    } catch (NoSuchMethodException var2) {
        throw new NoSuchMethodError(var2.getMessage());
    } catch (ClassNotFoundException var3) {
        throw new NoClassDefFoundError(var3.getMessage());
    }
}
</code></pre>

<p>}
<code>``
这样好多问题就迎刃而解。  
为什么</code>Java动态代理<code>必须是接口，因为生成的类要去实现这个接口。  
</code>invoke<code>方法的</code>proxy<code>是干嘛的，通过</code>super.h.invoke(this, m3, (Object[])null);<code>我们可以发现传递给</code>invoke<code>方法的就是</code>Proxy<code>本身。  
同时</code>Proxy<code>类也通过反射实现了</code>toString<code>,</code>equals<code>,和</code>hashcode<code>等方法。  
自此关于</code>Java动态代理<code>的讲解已经告段落，下面让我们简单看一下</code>Spring-mybatis<code>中关于</code>Java动态代理`的使用。</p>

<h2>Java动态代理在Spring-mybatis中的实现</h2>

<p>关于<code>Spring-mybatis</code>的实现我们得从<code>MapperScannerConfigurer</code>说起，首先<code>MapperScannerConfigurer</code>实现了<code>BeanDefinitionRegistryPostProcessor</code>接口。而<code>BeanDefinitionRegistryPostProcessor</code>依赖于<code>Spring</code>框架，简单的说<code>BeanDefinitionRegistryPostProcessor</code>使得我们可以将<code>BeanDefinition</code>添加到<code>BeanDefinitionRegistry</code>中，而<code>BeanDefinition</code>描述了一个Bean实例所拥有的实例、结构参数和参数值，简单点说拥有它就可以实例化<code>Bean</code>了。<code>BeanDefinitionRegistryPostProcessor</code>的<code>postProcessBeanDefinitionRegistry</code>方法在<code>Bean</code>被定义但还没被创建的时候执行，所以<code>Spring-mybatis</code>也是借助了这一点。需要想需要更深入的了解可以查看<code>Spring</code>的生命周期。
<code>java MapperScannerConfigurer.java片段
public class MapperScannerConfigurer implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware {
  /**
   * {@inheritDoc}
   *
   * @since 1.0.2
   */
  @Override
  public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
    scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));
  }
</code>
由上代码我们可以看到在<code>postProcessBeanDefinitionRegistry</code>里面得到<code>registry</code>然后使用<code>ClassPathMapperScanner</code>开始扫描包路径得到的<code>Bean</code>并且注册到<code>registry</code>里面。我们接着往里面看。
<figure class='code'><figcaption><span>ClassPathMapperScanner.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">public</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">BeanDefinitionHolder</span><span class="o">&gt;</span> <span class="nf">doScan</span><span class="o">(</span><span class="n">String</span><span class="o">&amp;</span><span class="n">hellip</span><span class="o">;</span> <span class="n">basePackages</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'><span class="n">Set</span><span class="o">&lt;</span><span class="n">BeanDefinitionHolder</span><span class="o">&gt;</span> <span class="n">beanDefinitions</span> <span class="o">=</span> <span class="kd">super</span><span class="o">.</span><span class="na">doScan</span><span class="o">(</span><span class="n">basePackages</span><span class="o">);&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">if</span> <span class="o">(</span><span class="n">beanDefinitions</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">logger</span><span class="o">.</span><span class="na">warn</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">No</span> <span class="n">MyBatis</span> <span class="n">mapper</span> <span class="n">was</span> <span class="n">found</span> <span class="n">in</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="o">;&amp;</span><span class="n">rdquo</span><span class="o">;</span> <span class="o">+</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">basePackages</span><span class="o">)</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;&amp;</span><span class="n">rsquo</span><span class="o">;</span> <span class="n">package</span><span class="o">.</span> <span class="n">Please</span> <span class="n">check</span> <span class="n">your</span> <span class="n">configuration</span><span class="o">.&amp;</span><span class="n">rdquo</span><span class="o">;);</span>
</span><span class='line'><span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">processBeanDefinitions</span><span class="o">(</span><span class="n">beanDefinitions</span><span class="o">);</span>
</span><span class='line'><span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">return</span> <span class="n">beanDefinitions</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="err">`</span><span class="n">ClassPathMapperScanner</span><span class="err">`</span><span class="n">继承了</span><span class="err">`</span><span class="n">Spring</span><span class="err">`</span><span class="n">的</span><span class="err">`</span><span class="n">ClassPathBeanDefinitionScanner</span><span class="err">`</span><span class="n">所以调用父类的</span><span class="err">`</span><span class="n">doScan</span><span class="err">`</span><span class="n">方法就可以加载</span><span class="err">`</span><span class="n">Bean</span><span class="err">`</span><span class="n">然后再通过</span><span class="err">`</span><span class="n">processBeanDefinitions</span><span class="err">`</span><span class="n">方法加工成</span><span class="err">`</span><span class="n">MyBatis</span><span class="err">`</span><span class="n">需要的</span><span class="err">`</span><span class="n">Bean</span><span class="err">`。</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">java</span> <span class="n">ClassPathMapperScanner</span><span class="o">.</span><span class="na">java片段</span>
</span><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">processBeanDefinitions</span><span class="o">(</span><span class="n">Set</span><span class="o">&lt;</span><span class="n">BeanDefinitionHolder</span><span class="o">&gt;</span> <span class="n">beanDefinitions</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">GenericBeanDefinition</span> <span class="n">definition</span><span class="o">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="n">BeanDefinitionHolder</span> <span class="n">holder</span> <span class="o">:</span> <span class="n">beanDefinitions</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">definition</span> <span class="o">=</span> <span class="o">(</span><span class="n">GenericBeanDefinition</span><span class="o">)</span> <span class="n">holder</span><span class="o">.</span><span class="na">getBeanDefinition</span><span class="o">();</span>
</span><span class='line'>      <span class="n">definition</span><span class="o">.</span><span class="na">setBeanClass</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">mapperFactoryBean</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">如上代码循环了所有由</span><span class="err">`</span><span class="n">Spring</span><span class="err">`</span><span class="n">容器解析出来的</span><span class="err">`</span><span class="n">beanDefinitions</span><span class="err">`</span><span class="n">然后把他们的</span><span class="err">`</span><span class="n">BeanClass</span><span class="err">`</span><span class="n">修改为</span><span class="err">`</span><span class="n">mapperFactoryBean</span><span class="err">`，</span><span class="n">这就进入了行文的重点</span><span class="err">。</span><span class="n">我们翻看到</span><span class="err">`</span><span class="n">MapperFactoryBean</span><span class="err">`</span><span class="o">:</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">java</span> <span class="n">MapperFactoryBean</span><span class="o">.</span><span class="na">java片段</span>
</span><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">checkDaoConfig</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'><span class="kd">super</span><span class="o">.</span><span class="na">checkDaoConfig</span><span class="o">();&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">notNull</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">mapperInterface</span><span class="o">,</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">Property</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="o">;</span><span class="n">mapperInterface</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="o">;</span> <span class="n">is</span> <span class="n">required</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;);&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">Configuration</span> <span class="n">configuration</span> <span class="o">=</span> <span class="n">getSqlSession</span><span class="o">().</span><span class="na">getConfiguration</span><span class="o">();</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">addToConfig</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="o">!</span><span class="n">configuration</span><span class="o">.</span><span class="na">hasMapper</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">mapperInterface</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">configuration</span><span class="o">.</span><span class="na">addMapper</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">mapperInterface</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">Error</span> <span class="k">while</span> <span class="n">adding</span> <span class="n">the</span> <span class="n">mapper</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="o">;&amp;</span><span class="n">rdquo</span><span class="o">;</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">mapperInterface</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;&amp;</span><span class="n">rsquo</span><span class="o">;</span> <span class="n">to</span> <span class="n">configuration</span><span class="o">.&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="n">e</span><span class="o">);</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">ErrorContext</span><span class="o">.</span><span class="na">instance</span><span class="o">().</span><span class="na">reset</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">其调用了</span><span class="err">`</span><span class="n">Configuration</span><span class="err">`</span><span class="n">的</span><span class="err">`</span><span class="n">addMapper</span><span class="err">`</span><span class="n">方法</span><span class="err">，</span><span class="n">这样就把</span><span class="err">`</span><span class="n">Bean</span><span class="err">`</span><span class="n">交给</span><span class="err">`</span><span class="n">MyBatis</span><span class="err">`</span><span class="n">管理了</span><span class="err">。</span><span class="n">那么</span><span class="err">`</span><span class="n">checkDaoConfig</span><span class="err">`</span><span class="n">是什么时候调用的呢</span><span class="err">？</span><span class="n">我们翻看其父类</span><span class="err">`</span><span class="n">DaoSupport</span><span class="err">`</span><span class="nl">可以看到:</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">java</span> <span class="n">DaoSupport</span><span class="o">.</span><span class="na">java片段</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">DaoSupport</span> <span class="kd">implements</span> <span class="n">InitializingBean</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">afterPropertiesSet</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IllegalArgumentException</span><span class="o">,</span> <span class="n">BeanInitializationException</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">checkDaoConfig</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">因为</span><span class="err">`</span><span class="n">DaoSupport</span><span class="err">`</span><span class="n">实现了</span><span class="err">`</span><span class="n">InitializingBean</span><span class="err">`</span><span class="n">并重写</span><span class="err">`</span><span class="n">afterPropertiesSet</span><span class="err">`</span><span class="n">方法</span><span class="err">，</span><span class="n">了解</span><span class="err">`</span><span class="n">Spring</span><span class="err">`</span><span class="n">生命周期的同学知道</span><span class="err">`</span><span class="n">afterPropertiesSet</span><span class="err">`</span><span class="n">方法会在资源加载完以后</span><span class="err">，</span><span class="n">初始化bean之前执行</span><span class="err">。</span><span class="n">我们继续查看</span><span class="err">`</span><span class="n">addMapper</span><span class="err">`</span><span class="n">方法</span><span class="err">。</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">java</span> <span class="n">MapperRegistry</span><span class="o">.</span><span class="na">java片段</span>
</span><span class='line'><span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">addMapper</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">type</span><span class="o">.</span><span class="na">isInterface</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">hasMapper</span><span class="o">(</span><span class="n">type</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">throw</span> <span class="k">new</span> <span class="nf">BindingException</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">Type</span> <span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;</span> <span class="o">+</span> <span class="n">type</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span> <span class="n">is</span> <span class="n">already</span> <span class="n">known</span> <span class="n">to</span> <span class="n">the</span> <span class="n">MapperRegistry</span><span class="o">.&amp;</span><span class="n">rdquo</span><span class="o">;);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="kt">boolean</span> <span class="n">loadCompleted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>      <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">knownMappers</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="k">new</span> <span class="n">MapperProxyFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;(</span><span class="n">type</span><span class="o">));</span>
</span><span class='line'>        <span class="c1">// It&amp;rsquo;s important that the type is added before the parser is run</span>
</span><span class='line'>        <span class="c1">// otherwise the binding may automatically be attempted by the</span>
</span><span class='line'>        <span class="c1">// mapper parser. If the type is already known, it won&amp;rsquo;t try.</span>
</span><span class='line'>        <span class="n">MapperAnnotationBuilder</span> <span class="n">parser</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">MapperAnnotationBuilder</span><span class="o">(</span><span class="n">config</span><span class="o">,</span> <span class="n">type</span><span class="o">);</span>
</span><span class='line'>        <span class="n">parser</span><span class="o">.</span><span class="na">parse</span><span class="o">();</span>
</span><span class='line'>        <span class="n">loadCompleted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">loadCompleted</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">knownMappers</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">type</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="err">`</span><span class="n">addMapper</span><span class="err">`</span><span class="n">方法最终创建了</span><span class="err">`</span><span class="n">MapperProxyFactory</span><span class="err">`</span><span class="n">对象</span><span class="err">，</span><span class="n">在</span><span class="err">`</span><span class="n">MapperProxyFactory</span><span class="err">`</span><span class="n">里面我们两眼泪汪汪地发现了似曾相识的代码</span><span class="err">：</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">java</span> <span class="n">MapperProxyFactory</span><span class="o">.</span><span class="na">java片段</span>
</span><span class='line'><span class="kd">protected</span> <span class="n">T</span> <span class="nf">newInstance</span><span class="o">(</span><span class="n">MapperProxy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">mapperProxy</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">(</span><span class="n">T</span><span class="o">)</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">mapperInterface</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Class</span><span class="o">[]</span> <span class="o">{</span> <span class="n">mapperInterface</span> <span class="o">},</span> <span class="n">mapperProxy</span><span class="o">);</span>
</span><span class='line'><span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kd">public</span> <span class="n">T</span> <span class="nf">newInstance</span><span class="o">(</span><span class="n">SqlSession</span> <span class="n">sqlSession</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">MapperProxy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">mapperProxy</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MapperProxy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;(</span><span class="n">sqlSession</span><span class="o">,</span> <span class="n">mapperInterface</span><span class="o">,</span> <span class="n">methodCache</span><span class="o">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">newInstance</span><span class="o">(</span><span class="n">mapperProxy</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">而</span><span class="err">`</span><span class="n">MapperProxy</span><span class="err">`</span><span class="n">实现了</span><span class="err">`</span><span class="n">InvocationHandler</span><span class="err">`</span><span class="n">方法</span><span class="err">，</span><span class="n">最终实现对</span><span class="err">`</span><span class="n">Bean</span><span class="err">`</span><span class="n">的代理</span><span class="err">，</span><span class="n">同时获取到上下文的</span><span class="err">`</span><span class="n">sqlSession</span><span class="err">`</span><span class="n">以供使用</span><span class="err">。</span><span class="n">具体生成过程我们不再累述</span><span class="err">，</span><span class="n">直接通过其源码结束本篇文章</span><span class="err">：</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">java</span> <span class="n">MapperProxy</span><span class="o">.</span><span class="na">java片段</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MapperProxy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">InvocationHandler</span><span class="o">,</span> <span class="n">Serializable</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">6424540398559729838L</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">final</span> <span class="n">SqlSession</span> <span class="n">sqlSession</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">mapperInterface</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Method</span><span class="o">,</span> <span class="n">MapperMethod</span><span class="o">&gt;</span> <span class="n">methodCache</span><span class="o">;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="kd">public</span> <span class="nf">MapperProxy</span><span class="o">(</span><span class="n">SqlSession</span> <span class="n">sqlSession</span><span class="o">,</span> <span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">mapperInterface</span><span class="o">,</span> <span class="n">Map</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Method</span><span class="o">,</span> <span class="n">MapperMethod</span><span class="o">&gt;</span> <span class="n">methodCache</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">this</span><span class="o">.</span><span class="na">sqlSession</span> <span class="o">=</span> <span class="n">sqlSession</span><span class="o">;</span>
</span><span class='line'>    <span class="k">this</span><span class="o">.</span><span class="na">mapperInterface</span> <span class="o">=</span> <span class="n">mapperInterface</span><span class="o">;</span>
</span><span class='line'>    <span class="k">this</span><span class="o">.</span><span class="na">methodCache</span> <span class="o">=</span> <span class="n">methodCache</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">Object</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getDeclaringClass</span><span class="o">()))</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">isDefaultMethod</span><span class="o">(</span><span class="n">method</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nf">invokeDefaultMethod</span><span class="o">(</span><span class="n">proxy</span><span class="o">,</span> <span class="n">method</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">throw</span> <span class="n">ExceptionUtil</span><span class="o">.</span><span class="na">unwrapThrowable</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">MapperMethod</span> <span class="n">mapperMethod</span> <span class="o">=</span> <span class="n">cachedMapperMethod</span><span class="o">(</span><span class="n">method</span><span class="o">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">mapperMethod</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">sqlSession</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<h2>参考链接</h2>

<p><a href="http://www.mybatis.org/spring/getting-started.html">Spring Mybatis 配置</a>  <br/>
<a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/">Spring Boot Mybatis</a><br/>
<a href="https://stackoverflow.com/questions/22930195/understanding-proxy-arguments-of-the-invoke-method-of-java-lang-reflect-invoca">InvocationHandler Proxy Parameter</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Idea 创建 Spring Boot 项目]]></title>
    <link href="http://www.majiang.life/blog/spring-boot-get-started/"/>
    <updated>2017-06-22T22:22:14+08:00</updated>
    <id>http://www.majiang.life/blog/spring-boot-get-started</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>最近 <code>Spring Boot</code> 如火如荼，于是也开始试试，不过上手真的太简单了。<code>Idea</code>非常方便的就可以创建，或者直接<code>clone</code>官方的例子<a href="https://spring.io/guides/gs/spring-boot/">https://spring.io/guides/gs/spring-boot/</a>。通俗理解<code>Spring Boot</code>就是一个<code>平台</code>，让你非常便捷的构建和运行一个项目，并且他是基于组件化的，你想用什么直接<code>拿来主义</code>就可以了，话不多少直接上手。</p>

<!-- more -->


<h2>使用 <code>Idea</code> 快速搭建</h2>

<p>选择<code>Spring Initialiar</code>直接创建。
<img src="/images/posts/spring-boot-get-started-1.png" alt="spring-boot-get-started-1" /></p>

<p>填写好<code>Group</code>和<code>Artifact</code>。
<img src="/images/posts/spring-boot-get-started-2.png" alt="spring-boot-get-started-2" /></p>

<p>下面直接选择<code>Web</code>就可以了，但是如果你想选择其他的直接勾选就行，她会自动为你加载依赖。并且一些<code>dependency</code>不需要配置版本，每一个<code>Spring Boot</code>的<code>parent</code>项目集成管理，这样省去了好多兼容麻烦。
<img src="/images/posts/spring-boot-get-started-3.png" alt="spring-boot-get-started-3" /></p>

<p>我们写一个<code>HelloController</code>试一下效果。
<img src="/images/posts/spring-boot-get-started-4.png" alt="spring-boot-get-started-4" /></p>

<p>最后访问<code>http://localhost:8080</code>成功。
<img src="/images/posts/spring-boot-get-started-5.png" alt="spring-boot-get-started-5" /></p>

<p>如果想改变端口也是非常简单的。
<img src="/images/posts/spring-boot-get-started-6.png" alt="spring-boot-get-started-6" /></p>
]]></content>
  </entry>
  
</feed>
