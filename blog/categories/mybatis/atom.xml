<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mybatis | 码匠笔记]]></title>
  <link href="http://www.majiang.life/blog/categories/mybatis/atom.xml" rel="self"/>
  <link href="http://www.majiang.life/"/>
  <updated>2018-02-23T11:46:09+08:00</updated>
  <id>http://www.majiang.life/</id>
  <author>
    <name><![CDATA[麻酱]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[从 Spring 集成 Mybatis 到 浅析Java动态代理]]></title>
    <link href="http://www.majiang.life/blog/spring-mybatis-and-dynamic-proxy/"/>
    <updated>2017-10-15T21:10:30+08:00</updated>
    <id>http://www.majiang.life/blog/spring-mybatis-and-dynamic-proxy</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>因为 <code>MyBatis</code> 的易上手性和可控性，使得它成为了<code>ORM</code>框架中的首选。近日新起了一个项目，所以重新搭建了一下 <code>Spring-mybatis</code>, 下面是搭建笔记和从<code>Spring-mybatis</code>源码分析其如何使用<code>Java动态代理</code>，希望对大家有帮助。</p>

<!-- more -->


<h2>Spring 集成 Mybatis</h2>

<p><code>Spring</code> 集成 <code>Mybatis</code>的方式有很多种，大家耳熟能详的<code>xml</code>配置方式或者本文的采用的方式：<br/>
首先需要添加<code>MyBatis</code>的和<code>MyBatis-Spring</code>的依赖，本文使用的<code>Spring-mybatis</code>版本是1.3.1。在<code>mvnrepository</code>里面我们可以找到当前<code>Spring-mybatis</code>依赖的<code>spring</code>和<code>mybatis</code>版本，最好是选择匹配的版本以避免处理不必要的兼容性问题。因为<code>MyBatis-Spring</code>中对<code>mybatis</code>的依赖选择了<code>provided</code>模式，所以我们不得不额外添加<code>mybatis</code>依赖，依赖配置如下。
<code>xml pom.xml
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;1.3.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
      &lt;version&gt;3.4.1&lt;/version&gt;
&lt;/dependency&gt;
</code>
接下来会我们要创建工厂bean,放置下面的代码在 Spring 的 XML 配置文件中:<br/>
<code>xml applicationContext.xml
&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;
  &lt;property name="dataSource" ref="dataSource" /&gt;
&lt;/bean&gt;
</code><br/>
这个工厂需要一个<code>DataSource</code>，就是我们熟知的数据源了。这里我们选择了阿里的<code>Druid</code>，同样我们需要引入两个配置
<code>xml pom.xml
&lt;dependency&gt;
 &lt;groupId&gt;mysql&lt;/groupId&gt;
 &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
 &lt;version&gt;5.1.41&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
 &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
 &lt;artifactId&gt;druid&lt;/artifactId&gt;
 &lt;version&gt;1.1.2&lt;/version&gt;
&lt;/dependency&gt;
</code>          <br/>
添加<code>Spring</code>配置如下
<code>xml applicationContext.xml
&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt;
        &lt;!-- 基本属性 url、user、password --&gt;
        &lt;property name="url"&gt;
            &lt;value&gt;&lt;![CDATA[${db.url}]]&gt;&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="username" value="${db.username}"/&gt;
        &lt;property name="password" value="${db.password}"/&gt;       
        &lt;!-- 省略其他配置 --&gt;   
&lt;/bean&gt;
</code>
接下来我们要编写数据库访问对象，大多数人会把它叫做<code>DAO</code>或者<code>Repository</code>，在这里其被称为<code>Mapper</code>，也是因为它的实现方式所决定。要注意的是所指定的映射器类必须是一个接口，而不是具体的实现类。这便因为<code>Mybatis</code>的内部实现使用的是<code>Java动态代理</code>，而<code>Java动态代理</code>只支持接口，关于<code>动态代理</code>我们下文有更详细的描述。
<code>java UserMapper.java
public interface UserMapper {
  @Select("SELECT * FROM users WHERE id = #{userId}")
  User getUser(@Param("userId") String userId);
}
</code>
接下来可以使用 <code>MapperFactoryBean</code>,像下面这样来把接口加入到 <code>Spring</code> 中，这样就把 <code>UserMapper</code> 和 <code>SessionFactory</code>关联到一起了，原来使用<code>xml</code>配置的时候还需要Dao继承<code>SqlSessionDaoSupport</code>才能注入<code>SessionFactory</code>，这种方式直接通过<code>Java动态代理</code>把<code>SqlSessionFactory</code>代理给了<code>UserMapper</code>，使得我们直接使用<code>UserMapper</code>即可。配置如下。
<code>xml applicationContext.xml
&lt;bean id="userMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt;
  &lt;property name="mapperInterface" value="org.mybatis.spring.sample.mapper.UserMapper" /&gt;
  &lt;property name="sqlSessionFactory" ref="sqlSessionFactory" /&gt;
&lt;/bean&gt;
</code>
这样我们已经完成了90%，就差调用了，前提是你<code>Spring</code>环境是OK的。调用 <code>MyBatis</code> 数据方法现在只需一行代码:
&#8220;`java FooServiceImpl.java
public class FooServiceImpl implements FooService {</p>

<p>private UserMapper userMapper;</p>

<p>public void setUserMapper(UserMapper userMapper) {
  this.userMapper = userMapper;
}</p>

<p>public User doSomeBusinessStuff(String userId) {
  return this.userMapper.getUser(userId);
}
<code>
那么问题又来了，每次写一个DAO都需要为其写一个`Bean`配置，那不是累死？于是我们又寻找另一种方案，代替手动声明`*Mapper`。`MapperScannerConfigurer`的出现解决了这个问题， 它会根据你配置的包路径自动的扫描类文件并自动将它们创建成`MapperFactoryBean`，可以在 Spring 的配置中添加如下代码:
</code>xml applicationContext.xml
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
  <property name="basePackage" value="com.github.codedrinker.mapper" />
</bean>
<code>
`basePackage`属性是让你为映射器接口文件设置基本的包路径。你可以使用分号或逗号作为分隔符设置多于一个的包路径。这个时候如果想自定义`sqlSessionFactory`可以添加如下配置：
</code>xml applicationContext.xml
<property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" />
<code>``
这样以后还有一点点小瑕疵，如果我们数据的</code>column<code>名字是</code>_<code>连接的，那么它不会那么聪明自动转换为驼峰的变量，所以我们需要对</code>SqlSessionFactoryBean`做如下配置，但是在1.3.0以后才可以通过xml配置，如果用早起版本的需要注意了。</p>

<pre><code class="xml applicationContext.xml">&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;
  &lt;property name="dataSource" ref="dataSource" /&gt;
  &lt;property name="configuration"&gt;
    &lt;bean class="org.apache.ibatis.session.Configuration"&gt;
      &lt;property name="mapUnderscoreToCamelCase" value="true"/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p>至此关于<code>Spring MyBatis</code>的配置已经全部结束，后面我们会简单说下<code>Spring MyBatis</code>中的动态代理。</p>

<h2>浅析 Java 动态代理</h2>

<p><code>JDK</code>自带的动态代理需要了解InvocationHandler接口和Proxy类，他们都是在java.lang.reflect包下。<br/>
<code>InvocationHandler</code>是代理实例的调用处理程序实现的接口。每个代理实例都具有一个关联的<code>InvocationHandler</code>。对代理实例调用方法时，这个方法会调用<code>InvocationHandler</code>的<code>invoke</code>方法。
<code>Proxy</code>提供静态方法用于创建动态代理类和实例,同时后面自动生成的代理类都是<code>Proxy</code>对象。下面我们直接通过代码来分析<code>Java动态代理</code>：
<code>InvocationInterceptor</code>实现<code>InvocationHandler</code>接口，用于处理具体的代理逻辑。
&#8220;`java InvocationInterceptor.java
/<em>*
 * Created by codedrinker on 12/10/2017.
 </em>/
public class InvocationInterceptor implements InvocationHandler {
    private Object target;</p>

<pre><code>public InvocationInterceptor(Object target) {
    this.target = target;
}
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    System.out.println("before user create");
    method.invoke(target, args);
    System.out.println("end user create");
    return null;
}
</code></pre>

<p>}
<code>
`User`和`UserImpl`是被代理对象的接口和类
</code>java User.java
/<em>*
 * Created by codedrinker on 12/10/2017.
 </em>/
public interface User {
    void create();
}</p>

<p><code>
</code>java UserImpl.java
/<strong>
 * Created by codedrinker on 12/10/2017.
 */
public class UserImpl implements User {
    @Override
    public void create() {
        System.out.println(&ldquo;create user&rdquo;);
    }
}
<code>
`DynamicProxyTest`是测试类，用于创建`InvocationInterceptor`和`Proxy`类以便测试。
</code>java DynamicProxyTest.java
/</strong>
 * Created by codedrinker on 12/10/2017.
 <em>/
public class DynamicProxyTest {
    public static void main(String[] args) {
        User target = new UserImpl();
        InvocationInterceptor invocationInterceptor = new InvocationInterceptor(target);
        User proxyInstance = (User) Proxy.newProxyInstance(UserImpl.class.getClassLoader(),
                UserImpl.class.getInterfaces(),
                invocationInterceptor);
        proxyInstance.create();
    }
}
<code>
输入结果如下：
</code>sh
before user create
create user
end user create
<code>
很明显，我们通过proxyInstance这个代理类进行方法调用的时候，会在方法调用前后进行输出打印，这样就简单的实现了一个`Java动态代理`例子。动态代理不仅仅是打印输出这么简单，我们可以通过它打印日志，打开关闭事务， 权限检查了等等。当然它更是许多框架的钟爱，就如下文我们要说的`MyBatis`中`Java动态代理`的实现。再多说一句`Spring`的`AOP`也是使用动态代理实现的，当然它同时使用了`Java动态代理`和`CGLib`两种方式。不过`CGLIB`不是本文要讨论的范围。  
注意观察的同学看到上面代码的时候可能发现`invoke`方法的`proxy`参数并没有被使用，笔者查阅了一些相关文档也没有找到合理的说法，只能在源码中看看究竟喽，笔者当前的JDK版本是1.8。我们从入口开始，`Proxy.newProxyInstance`:
</code>java Proxy.java片段
/</em>
 * Look up or generate the designated proxy class.
 */
@CallerSensitive
public static Object newProxyInstance(ClassLoader loader,
                                      Class&lt;?>[] interfaces,
                                      InvocationHandler h)
    throws IllegalArgumentException
{
    Class&lt;?> cl = getProxyClass0(loader, intfs);
}
<code>
如上代码由此可见，它调用了`getProxyClass0`来获取`Proxy Class`，那我们继续往下看。
</code>java Proxy.java片段
private static Class&lt;?> getProxyClass0(ClassLoader loader,
                                           Class&lt;?>&hellip; interfaces) {
    if (interfaces.length > 65535) {
        throw new IllegalArgumentException(&ldquo;interface limit exceeded&rdquo;);
    }
    //If the proxy class defined by the given loader implementing
    //the given interfaces exists, this will simply return the cached copy;
    //otherwise, it will create the proxy class via the ProxyClassFactory
    return proxyClassCache.get(loader, interfaces);
}
<code>
其实上面写的已经很简单了，如果存在就在`proxyClassCache`里面获取到，如果不存在就使用`ProxyClassFactory`创建一个。当然我们如果看一下`proxyClassCache`变量的话其也是`ProxyClassFactory`对象。
</code>java
   private static final WeakCache&lt;ClassLoader, Class&lt;?>[], Class&lt;?>>
        proxyClassCache = new WeakCache&lt;>(new KeyFactory(), new ProxyClassFactory());
<code>
那么我们直接就去查看`ProxyClassFactory`的实现问题不就解决了吗？
</code>java Proxy.java片段
    private static final class ProxyClassFactory
        implements BiFunction&lt;ClassLoader, Class&lt;?>[], Class&lt;?>>
    {
        // prefix for all proxy class names
        private static final String proxyClassNamePrefix = &ldquo;$Proxy&rdquo;;
        //next number to use for generation of unique proxy class names
        private static final AtomicLong nextUniqueNumber = new AtomicLong();
        @Override
        public Class&lt;?> apply(ClassLoader loader, Class&lt;?>[] interfaces) {</p>

<pre><code>        String proxyName = proxyPkg + proxyClassNamePrefix + num;
        /*
         * Generate the specified proxy class.
         */
        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
            proxyName, interfaces, accessFlags);
    }
}
</code></pre>

<pre><code>由上代码便一目了然了，为什么我们`Debug`的时候`Proxy`对象是`$Proxy0`，是因为他通过`$Proxy`和`AtomicLong`拼起来的类名，其实这不是重点。重点是`ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags)`。这就是生成`class`的地方，它把所有的条件组合好，生成`class`文件，然后再加载到内存里面以供使用。有兴趣的同学可以继续往深处查看。而我们需要做的是获取到他生成的字节码，看一下里面到底是什么？当`saveGeneratedFiles`为`true`的时候会保存`class`文件，所以我们在`DynamicProxyTest`的`main`函数添加一行即可：
</code></pre>

<p>System.setProperty(&ldquo;sun.misc.ProxyGenerator.saveGeneratedFiles&rdquo;, &ldquo;true&rdquo;);
<code>
通过`Debug`我们可以发现，它存储`class`文件的路径是`com/sun/proxy/$Proxy0.class`，所以直接在我们项目的目录下面就能找到它，然后通过`Idea`打开便得到如下代码：
</code>java $Proxy0.class
public final class $Proxy0 extends Proxy implements User {
    private static Method m1;
    private static Method m2;
    private static Method m3;
    private static Method m0;</p>

<pre><code>public $Proxy0(InvocationHandler var1) throws  {
    super(var1);
}

public final boolean equals(Object var1) throws  {
    try {
        return ((Boolean)super.h.invoke(this, m1, new Object[]{var1})).booleanValue();
    } catch (RuntimeException | Error var3) {
        throw var3;
    } catch (Throwable var4) {
        throw new UndeclaredThrowableException(var4);
    }
}

public final String toString() throws  {
    try {
        return (String)super.h.invoke(this, m2, (Object[])null);
    } catch (RuntimeException | Error var2) {
        throw var2;
    } catch (Throwable var3) {
        throw new UndeclaredThrowableException(var3);
    }
}

public final void create() throws  {
    try {
        super.h.invoke(this, m3, (Object[])null);
    } catch (RuntimeException | Error var2) {
        throw var2;
    } catch (Throwable var3) {
        throw new UndeclaredThrowableException(var3);
    }
}

public final int hashCode() throws  {
    try {
        return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();
    } catch (RuntimeException | Error var2) {
        throw var2;
    } catch (Throwable var3) {
        throw new UndeclaredThrowableException(var3);
    }
}

static {
    try {
        m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[]{Class.forName("java.lang.Object")});
        m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]);
        m3 = Class.forName("local.dynimicproxy.User").getMethod("create", new Class[0]);
        m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);
    } catch (NoSuchMethodException var2) {
        throw new NoSuchMethodError(var2.getMessage());
    } catch (ClassNotFoundException var3) {
        throw new NoClassDefFoundError(var3.getMessage());
    }
}
</code></pre>

<p>}
<code>``
这样好多问题就迎刃而解。  
为什么</code>Java动态代理<code>必须是接口，因为生成的类要去实现这个接口。  
</code>invoke<code>方法的</code>proxy<code>是干嘛的，通过</code>super.h.invoke(this, m3, (Object[])null);<code>我们可以发现传递给</code>invoke<code>方法的就是</code>Proxy<code>本身。  
同时</code>Proxy<code>类也通过反射实现了</code>toString<code>,</code>equals<code>,和</code>hashcode<code>等方法。  
自此关于</code>Java动态代理<code>的讲解已经告段落，下面让我们简单看一下</code>Spring-mybatis<code>中关于</code>Java动态代理`的使用。</p>

<h2>Java动态代理在Spring-mybatis中的实现</h2>

<p>关于<code>Spring-mybatis</code>的实现我们得从<code>MapperScannerConfigurer</code>说起，首先<code>MapperScannerConfigurer</code>实现了<code>BeanDefinitionRegistryPostProcessor</code>接口。而<code>BeanDefinitionRegistryPostProcessor</code>依赖于<code>Spring</code>框架，简单的说<code>BeanDefinitionRegistryPostProcessor</code>使得我们可以将<code>BeanDefinition</code>添加到<code>BeanDefinitionRegistry</code>中，而<code>BeanDefinition</code>描述了一个Bean实例所拥有的实例、结构参数和参数值，简单点说拥有它就可以实例化<code>Bean</code>了。<code>BeanDefinitionRegistryPostProcessor</code>的<code>postProcessBeanDefinitionRegistry</code>方法在<code>Bean</code>被定义但还没被创建的时候执行，所以<code>Spring-mybatis</code>也是借助了这一点。需要想需要更深入的了解可以查看<code>Spring</code>的生命周期。
<code>java MapperScannerConfigurer.java片段
public class MapperScannerConfigurer implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware {
  /**
   * {@inheritDoc}
   *
   * @since 1.0.2
   */
  @Override
  public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
    scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));
  }
</code>
由上代码我们可以看到在<code>postProcessBeanDefinitionRegistry</code>里面得到<code>registry</code>然后使用<code>ClassPathMapperScanner</code>开始扫描包路径得到的<code>Bean</code>并且注册到<code>registry</code>里面。我们接着往里面看。
&#8220;`java ClassPathMapperScanner.java
@Override
public Set<BeanDefinitionHolder> doScan(String&hellip; basePackages) {
Set<BeanDefinitionHolder> beanDefinitions = super.doScan(basePackages);</p>

<p>if (beanDefinitions.isEmpty()) {
  logger.warn(&ldquo;No MyBatis mapper was found in &lsquo;&rdquo; + Arrays.toString(basePackages) + &ldquo;&rsquo; package. Please check your configuration.&rdquo;);
} else {
  processBeanDefinitions(beanDefinitions);
}</p>

<p>return beanDefinitions;
}
<code>
`ClassPathMapperScanner`继承了`Spring`的`ClassPathBeanDefinitionScanner`所以调用父类的`doScan`方法就可以加载`Bean`然后再通过`processBeanDefinitions`方法加工成`MyBatis`需要的`Bean`。
</code>java ClassPathMapperScanner.java片段
private void processBeanDefinitions(Set<BeanDefinitionHolder> beanDefinitions) {
    GenericBeanDefinition definition;
    for (BeanDefinitionHolder holder : beanDefinitions) {
      definition = (GenericBeanDefinition) holder.getBeanDefinition();
      definition.setBeanClass(this.mapperFactoryBean.getClass());
    }
  }
<code>
如上代码循环了所有由`Spring`容器解析出来的`beanDefinitions`然后把他们的`BeanClass`修改为`mapperFactoryBean`，这就进入了行文的重点。我们翻看到`MapperFactoryBean`:
</code>java MapperFactoryBean.java片段
@Override
protected void checkDaoConfig() {
super.checkDaoConfig();</p>

<p>notNull(this.mapperInterface, &ldquo;Property &lsquo;mapperInterface&rsquo; is required&rdquo;);</p>

<p>Configuration configuration = getSqlSession().getConfiguration();
if (this.addToConfig &amp;&amp; !configuration.hasMapper(this.mapperInterface)) {
  try {
    configuration.addMapper(this.mapperInterface);
  } catch (Exception e) {
    logger.error(&ldquo;Error while adding the mapper &lsquo;&rdquo; + this.mapperInterface + &ldquo;&rsquo; to configuration.&rdquo;, e);
    throw new IllegalArgumentException(e);
  } finally {
    ErrorContext.instance().reset();
  }
}
}
<code>
其调用了`Configuration`的`addMapper`方法，这样就把`Bean`交给`MyBatis`管理了。那么`checkDaoConfig`是什么时候调用的呢？我们翻看其父类`DaoSupport`可以看到:
</code>java DaoSupport.java片段
public abstract class DaoSupport implements InitializingBean {
    @Override
  public final void afterPropertiesSet() throws IllegalArgumentException, BeanInitializationException {
    checkDaoConfig();
  }
}
<code>
因为`DaoSupport`实现了`InitializingBean`并重写`afterPropertiesSet`方法，了解`Spring`生命周期的同学知道`afterPropertiesSet`方法会在资源加载完以后，初始化bean之前执行。我们继续查看`addMapper`方法。
</code>java MapperRegistry.java片段
public <T> void addMapper(Class<T> type) {
    if (type.isInterface()) {
      if (hasMapper(type)) {
        throw new BindingException(&ldquo;Type &rdquo; + type + &ldquo; is already known to the MapperRegistry.&rdquo;);
      }
      boolean loadCompleted = false;
      try {
        knownMappers.put(type, new MapperProxyFactory<T>(type));
        // It&rsquo;s important that the type is added before the parser is run
        // otherwise the binding may automatically be attempted by the
        // mapper parser. If the type is already known, it won&rsquo;t try.
        MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
        parser.parse();
        loadCompleted = true;
      } finally {
        if (!loadCompleted) {
          knownMappers.remove(type);
        }
      }
    }
}
<code>
`addMapper`方法最终创建了`MapperProxyFactory`对象，在`MapperProxyFactory`里面我们两眼泪汪汪地发现了似曾相识的代码：
</code>java MapperProxyFactory.java片段
protected T newInstance(MapperProxy<T> mapperProxy) {
    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);
}</p>

<p>public T newInstance(SqlSession sqlSession) {
    final MapperProxy<T> mapperProxy = new MapperProxy<T>(sqlSession, mapperInterface, methodCache);
    return newInstance(mapperProxy);
}
<code>
而`MapperProxy`实现了`InvocationHandler`方法，最终实现对`Bean`的代理，同时获取到上下文的`sqlSession`以供使用。具体生成过程我们不再累述，直接通过其源码结束本篇文章：
</code>java MapperProxy.java片段
public class MapperProxy<T> implements InvocationHandler, Serializable {</p>

<p>  private static final long serialVersionUID = -6424540398559729838L;
  private final SqlSession sqlSession;
  private final Class<T> mapperInterface;
  private final Map&lt;Method, MapperMethod> methodCache;</p>

<p>  public MapperProxy(SqlSession sqlSession, Class<T> mapperInterface, Map&lt;Method, MapperMethod> methodCache) {
    this.sqlSession = sqlSession;
    this.mapperInterface = mapperInterface;
    this.methodCache = methodCache;
  }</p>

<p>  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    try {
      if (Object.class.equals(method.getDeclaringClass())) {
        return method.invoke(this, args);
      } else if (isDefaultMethod(method)) {
        return invokeDefaultMethod(proxy, method, args);
      }
    } catch (Throwable t) {
      throw ExceptionUtil.unwrapThrowable(t);
    }
    final MapperMethod mapperMethod = cachedMapperMethod(method);
    return mapperMethod.execute(sqlSession, args);
  }
}
&#8220;`</p>

<h2>参考链接</h2>

<p><a href="http://www.mybatis.org/spring/getting-started.html">Spring Mybatis 配置</a>  <br/>
<a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/">Spring Boot Mybatis</a><br/>
<a href="https://stackoverflow.com/questions/22930195/understanding-proxy-arguments-of-the-invoke-method-of-java-lang-reflect-invoca">InvocationHandler Proxy Parameter</a></p>
]]></content>
  </entry>
  
</feed>
