<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Spring | 码匠笔记]]></title>
  <link href="http://www.majiang.life/blog/categories/spring/atom.xml" rel="self"/>
  <link href="http://www.majiang.life/"/>
  <updated>2018-02-23T11:46:09+08:00</updated>
  <id>http://www.majiang.life/</id>
  <author>
    <name><![CDATA[麻酱]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring 集成 Redis 扫雷]]></title>
    <link href="http://www.majiang.life/blog/quick-start-spring-data-redis/"/>
    <updated>2017-10-21T10:37:55+08:00</updated>
    <id>http://www.majiang.life/blog/quick-start-spring-data-redis</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>关于<code>Redis</code>已然是烂大街的技术了，但是近日新起了一个项目需要集成<code>Redis</code>，看了一下之前的封装实在是不怎么优雅，于是查了一下发现了一个非常简单的解决方案，那就是<code>Spring</code>家族的<code>Spring Data Redis</code>。话不多说直接“上码”:</p>

<!-- more -->


<h2>Spring Data Redis 介绍</h2>

<p>Spring Data Redis是Spring Data系列的一部分，它可以轻松地使得Spring应用程序配置和访问Redis。</p>

<h2>快速搭建 Spring Data Redis</h2>

<p>直接可以参照官方地址进行配置，以往的<code>Spring</code>的文档都写着预计阅读时间，这个没有写你就知道有多简单啦。你可以直接<a href="http://projects.spring.io/spring-data-redis/">点击查看官方文档</a>，或者往下阅读。<br/>
<code>Maven</code>直接引入如下依赖：
<code>xml pom.xml
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
        &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;
        &lt;version&gt;1.8.8.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;spring-libs-release&lt;/id&gt;
        &lt;name&gt;Spring Releases&lt;/name&gt;
        &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt;
        &lt;snapshots&gt;
            &lt;enabled&gt;false&lt;/enabled&gt;
        &lt;/snapshots&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;
</code>
然后直接在<code>Spring</code>的配置文件里面定义<code>bean</code>就可以了，官方没有说怎么配置<code>hostname</code>等等，但是点击<code>JedisConnectionFactory</code>里面一看就知道了，直接添加一行<code>p:host-name="172.10.23.234"</code>即可。
&#8220;`xml applicationContext.xml
<bean id="jedisConnFactory"
    class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"
    p:use-pool="true"
    p:host-name="172.10.23.234"
    /></p>

<!-- redis template definition -->


<p><bean id="redisTemplate"
    class="org.springframework.data.redis.core.RedisTemplate"
    p:connection-factory-ref="jedisConnFactory"/>
<code>
最后直接引入`bean`使用：
</code>java Example.java
public class Example {</p>

<pre><code>// inject the actual template
@Autowired
private RedisTemplate&lt;String, String&gt; template;

// inject the template as ListOperations
// can also inject as Value, Set, ZSet, and HashOperations
@Resource(name="redisTemplate")
private ListOperations&lt;String, String&gt; listOps;

public void addLink(String userId, URL url) {
    listOps.leftPush(userId, url.toExternalForm());
    // or use template directly
    redisTemplate.boundListOps(userId).leftPush(url.toExternalForm());
}
</code></pre>

<p>}
<code>``
如上，根据</code>Spring`的官方文档已经全部完成，是不是非常简单？那么接下来我们运行一下试一试。<br/>
这时候出现了第一个异常。</p>

<h2>NoClassDefFoundError 问题解决</h2>

<pre><code class="sh">nested exception is java.lang.NoClassDefFoundError: org/apache/commons/pool2/impl/GenericObjectPoolConfig
</code></pre>

<p>很明显是没有引入这个包嘛，我们直接从<code>spring-data-redis</code>的<code>pom.xml</code>里面可以看到多了一个<code>optional</code>属性。
<code>xml pom.xml[spring-data-redis]
  &lt;dependency&gt;
      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
      &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
      &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
</code>
那么这个问题就迎刃而解了，因为在<code>spring-data-redis</code>里面声明的<code>commons-pool2</code>是<code>optional</code>的，根据<code>Maven</code>的规则如果A项目依赖配置为optional的，那么依赖A项目的B项目如果不手动引入A里面optional的依赖B项目是不会自动引入依赖的的。说起来有点绕，反正就是导致我们必须手动添加下面的依赖。详情可以参照<code>Maven</code>的官方网文档。<a href="http://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html">点击查看官方文档</a>。
<code>xml pom.xml
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
    &lt;version&gt;2.2&lt;/version&gt;
&lt;/dependency&gt;
</code>
再次运行的时候我们发现了另一个问题
<code>sh
nested exception is java.lang.NoClassDefFoundError: redis/clients/jedis/JedisPoolConfig
</code>
这问题就显而易见了，直接添加如下到<code>pom.xml</code>中即可。
<code>xml pom.xml
&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
    &lt;version&gt;2.9.0&lt;/version&gt;
&lt;/dependency&gt;
</code>
这时候我们再次运行项目可以正常运行啦，然而有出现了一个奇怪的问题，存入<code>Redis</code>里面的<code>Key</code>有一个看起来像是乱码的前缀<code>\xac\xed\x00\x05t\x00</code>:</p>

<h2>\xac\xed\x00\x05t\x00 到底是啥</h2>

<p>出现这个问题的原因是因为其使用的默认是RedisTemplate，它使用的是Java的Serialization方式，所以会在前面有一段类似乱码的东西。如果是String作为key的话可以直接修改为StringRedisTemplate这个问题就修改了。</p>

<h2>参考链接</h2>

<p><a href="http://projects.spring.io/spring-data-redis/">Spring Data Redis</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从 Spring 集成 Mybatis 到 浅析Java动态代理]]></title>
    <link href="http://www.majiang.life/blog/spring-mybatis-and-dynamic-proxy/"/>
    <updated>2017-10-15T21:10:30+08:00</updated>
    <id>http://www.majiang.life/blog/spring-mybatis-and-dynamic-proxy</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>因为 <code>MyBatis</code> 的易上手性和可控性，使得它成为了<code>ORM</code>框架中的首选。近日新起了一个项目，所以重新搭建了一下 <code>Spring-mybatis</code>, 下面是搭建笔记和从<code>Spring-mybatis</code>源码分析其如何使用<code>Java动态代理</code>，希望对大家有帮助。</p>

<!-- more -->


<h2>Spring 集成 Mybatis</h2>

<p><code>Spring</code> 集成 <code>Mybatis</code>的方式有很多种，大家耳熟能详的<code>xml</code>配置方式或者本文的采用的方式：<br/>
首先需要添加<code>MyBatis</code>的和<code>MyBatis-Spring</code>的依赖，本文使用的<code>Spring-mybatis</code>版本是1.3.1。在<code>mvnrepository</code>里面我们可以找到当前<code>Spring-mybatis</code>依赖的<code>spring</code>和<code>mybatis</code>版本，最好是选择匹配的版本以避免处理不必要的兼容性问题。因为<code>MyBatis-Spring</code>中对<code>mybatis</code>的依赖选择了<code>provided</code>模式，所以我们不得不额外添加<code>mybatis</code>依赖，依赖配置如下。
<code>xml pom.xml
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;1.3.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
      &lt;version&gt;3.4.1&lt;/version&gt;
&lt;/dependency&gt;
</code>
接下来会我们要创建工厂bean,放置下面的代码在 Spring 的 XML 配置文件中:<br/>
<code>xml applicationContext.xml
&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;
  &lt;property name="dataSource" ref="dataSource" /&gt;
&lt;/bean&gt;
</code><br/>
这个工厂需要一个<code>DataSource</code>，就是我们熟知的数据源了。这里我们选择了阿里的<code>Druid</code>，同样我们需要引入两个配置
<code>xml pom.xml
&lt;dependency&gt;
 &lt;groupId&gt;mysql&lt;/groupId&gt;
 &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
 &lt;version&gt;5.1.41&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
 &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
 &lt;artifactId&gt;druid&lt;/artifactId&gt;
 &lt;version&gt;1.1.2&lt;/version&gt;
&lt;/dependency&gt;
</code>          <br/>
添加<code>Spring</code>配置如下
<code>xml applicationContext.xml
&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt;
        &lt;!-- 基本属性 url、user、password --&gt;
        &lt;property name="url"&gt;
            &lt;value&gt;&lt;![CDATA[${db.url}]]&gt;&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="username" value="${db.username}"/&gt;
        &lt;property name="password" value="${db.password}"/&gt;       
        &lt;!-- 省略其他配置 --&gt;   
&lt;/bean&gt;
</code>
接下来我们要编写数据库访问对象，大多数人会把它叫做<code>DAO</code>或者<code>Repository</code>，在这里其被称为<code>Mapper</code>，也是因为它的实现方式所决定。要注意的是所指定的映射器类必须是一个接口，而不是具体的实现类。这便因为<code>Mybatis</code>的内部实现使用的是<code>Java动态代理</code>，而<code>Java动态代理</code>只支持接口，关于<code>动态代理</code>我们下文有更详细的描述。
<code>java UserMapper.java
public interface UserMapper {
  @Select("SELECT * FROM users WHERE id = #{userId}")
  User getUser(@Param("userId") String userId);
}
</code>
接下来可以使用 <code>MapperFactoryBean</code>,像下面这样来把接口加入到 <code>Spring</code> 中，这样就把 <code>UserMapper</code> 和 <code>SessionFactory</code>关联到一起了，原来使用<code>xml</code>配置的时候还需要Dao继承<code>SqlSessionDaoSupport</code>才能注入<code>SessionFactory</code>，这种方式直接通过<code>Java动态代理</code>把<code>SqlSessionFactory</code>代理给了<code>UserMapper</code>，使得我们直接使用<code>UserMapper</code>即可。配置如下。
<code>xml applicationContext.xml
&lt;bean id="userMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt;
  &lt;property name="mapperInterface" value="org.mybatis.spring.sample.mapper.UserMapper" /&gt;
  &lt;property name="sqlSessionFactory" ref="sqlSessionFactory" /&gt;
&lt;/bean&gt;
</code>
这样我们已经完成了90%，就差调用了，前提是你<code>Spring</code>环境是OK的。调用 <code>MyBatis</code> 数据方法现在只需一行代码:
&#8220;`java FooServiceImpl.java
public class FooServiceImpl implements FooService {</p>

<p>private UserMapper userMapper;</p>

<p>public void setUserMapper(UserMapper userMapper) {
  this.userMapper = userMapper;
}</p>

<p>public User doSomeBusinessStuff(String userId) {
  return this.userMapper.getUser(userId);
}
<code>
那么问题又来了，每次写一个DAO都需要为其写一个`Bean`配置，那不是累死？于是我们又寻找另一种方案，代替手动声明`*Mapper`。`MapperScannerConfigurer`的出现解决了这个问题， 它会根据你配置的包路径自动的扫描类文件并自动将它们创建成`MapperFactoryBean`，可以在 Spring 的配置中添加如下代码:
</code>xml applicationContext.xml
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
  <property name="basePackage" value="com.github.codedrinker.mapper" />
</bean>
<code>
`basePackage`属性是让你为映射器接口文件设置基本的包路径。你可以使用分号或逗号作为分隔符设置多于一个的包路径。这个时候如果想自定义`sqlSessionFactory`可以添加如下配置：
</code>xml applicationContext.xml
<property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" />
<code>``
这样以后还有一点点小瑕疵，如果我们数据的</code>column<code>名字是</code>_<code>连接的，那么它不会那么聪明自动转换为驼峰的变量，所以我们需要对</code>SqlSessionFactoryBean`做如下配置，但是在1.3.0以后才可以通过xml配置，如果用早起版本的需要注意了。</p>

<pre><code class="xml applicationContext.xml">&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;
  &lt;property name="dataSource" ref="dataSource" /&gt;
  &lt;property name="configuration"&gt;
    &lt;bean class="org.apache.ibatis.session.Configuration"&gt;
      &lt;property name="mapUnderscoreToCamelCase" value="true"/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p>至此关于<code>Spring MyBatis</code>的配置已经全部结束，后面我们会简单说下<code>Spring MyBatis</code>中的动态代理。</p>

<h2>浅析 Java 动态代理</h2>

<p><code>JDK</code>自带的动态代理需要了解InvocationHandler接口和Proxy类，他们都是在java.lang.reflect包下。<br/>
<code>InvocationHandler</code>是代理实例的调用处理程序实现的接口。每个代理实例都具有一个关联的<code>InvocationHandler</code>。对代理实例调用方法时，这个方法会调用<code>InvocationHandler</code>的<code>invoke</code>方法。
<code>Proxy</code>提供静态方法用于创建动态代理类和实例,同时后面自动生成的代理类都是<code>Proxy</code>对象。下面我们直接通过代码来分析<code>Java动态代理</code>：
<code>InvocationInterceptor</code>实现<code>InvocationHandler</code>接口，用于处理具体的代理逻辑。
&#8220;`java InvocationInterceptor.java
/<em>*
 * Created by codedrinker on 12/10/2017.
 </em>/
public class InvocationInterceptor implements InvocationHandler {
    private Object target;</p>

<pre><code>public InvocationInterceptor(Object target) {
    this.target = target;
}
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    System.out.println("before user create");
    method.invoke(target, args);
    System.out.println("end user create");
    return null;
}
</code></pre>

<p>}
<code>
`User`和`UserImpl`是被代理对象的接口和类
</code>java User.java
/<em>*
 * Created by codedrinker on 12/10/2017.
 </em>/
public interface User {
    void create();
}</p>

<p><code>
</code>java UserImpl.java
/<strong>
 * Created by codedrinker on 12/10/2017.
 */
public class UserImpl implements User {
    @Override
    public void create() {
        System.out.println(&ldquo;create user&rdquo;);
    }
}
<code>
`DynamicProxyTest`是测试类，用于创建`InvocationInterceptor`和`Proxy`类以便测试。
</code>java DynamicProxyTest.java
/</strong>
 * Created by codedrinker on 12/10/2017.
 <em>/
public class DynamicProxyTest {
    public static void main(String[] args) {
        User target = new UserImpl();
        InvocationInterceptor invocationInterceptor = new InvocationInterceptor(target);
        User proxyInstance = (User) Proxy.newProxyInstance(UserImpl.class.getClassLoader(),
                UserImpl.class.getInterfaces(),
                invocationInterceptor);
        proxyInstance.create();
    }
}
<code>
输入结果如下：
</code>sh
before user create
create user
end user create
<code>
很明显，我们通过proxyInstance这个代理类进行方法调用的时候，会在方法调用前后进行输出打印，这样就简单的实现了一个`Java动态代理`例子。动态代理不仅仅是打印输出这么简单，我们可以通过它打印日志，打开关闭事务， 权限检查了等等。当然它更是许多框架的钟爱，就如下文我们要说的`MyBatis`中`Java动态代理`的实现。再多说一句`Spring`的`AOP`也是使用动态代理实现的，当然它同时使用了`Java动态代理`和`CGLib`两种方式。不过`CGLIB`不是本文要讨论的范围。  
注意观察的同学看到上面代码的时候可能发现`invoke`方法的`proxy`参数并没有被使用，笔者查阅了一些相关文档也没有找到合理的说法，只能在源码中看看究竟喽，笔者当前的JDK版本是1.8。我们从入口开始，`Proxy.newProxyInstance`:
</code>java Proxy.java片段
/</em>
 * Look up or generate the designated proxy class.
 */
@CallerSensitive
public static Object newProxyInstance(ClassLoader loader,
                                      Class&lt;?>[] interfaces,
                                      InvocationHandler h)
    throws IllegalArgumentException
{
    Class&lt;?> cl = getProxyClass0(loader, intfs);
}
<code>
如上代码由此可见，它调用了`getProxyClass0`来获取`Proxy Class`，那我们继续往下看。
</code>java Proxy.java片段
private static Class&lt;?> getProxyClass0(ClassLoader loader,
                                           Class&lt;?>&hellip; interfaces) {
    if (interfaces.length > 65535) {
        throw new IllegalArgumentException(&ldquo;interface limit exceeded&rdquo;);
    }
    //If the proxy class defined by the given loader implementing
    //the given interfaces exists, this will simply return the cached copy;
    //otherwise, it will create the proxy class via the ProxyClassFactory
    return proxyClassCache.get(loader, interfaces);
}
<code>
其实上面写的已经很简单了，如果存在就在`proxyClassCache`里面获取到，如果不存在就使用`ProxyClassFactory`创建一个。当然我们如果看一下`proxyClassCache`变量的话其也是`ProxyClassFactory`对象。
</code>java
   private static final WeakCache&lt;ClassLoader, Class&lt;?>[], Class&lt;?>>
        proxyClassCache = new WeakCache&lt;>(new KeyFactory(), new ProxyClassFactory());
<code>
那么我们直接就去查看`ProxyClassFactory`的实现问题不就解决了吗？
</code>java Proxy.java片段
    private static final class ProxyClassFactory
        implements BiFunction&lt;ClassLoader, Class&lt;?>[], Class&lt;?>>
    {
        // prefix for all proxy class names
        private static final String proxyClassNamePrefix = &ldquo;$Proxy&rdquo;;
        //next number to use for generation of unique proxy class names
        private static final AtomicLong nextUniqueNumber = new AtomicLong();
        @Override
        public Class&lt;?> apply(ClassLoader loader, Class&lt;?>[] interfaces) {</p>

<pre><code>        String proxyName = proxyPkg + proxyClassNamePrefix + num;
        /*
         * Generate the specified proxy class.
         */
        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
            proxyName, interfaces, accessFlags);
    }
}
</code></pre>

<pre><code>由上代码便一目了然了，为什么我们`Debug`的时候`Proxy`对象是`$Proxy0`，是因为他通过`$Proxy`和`AtomicLong`拼起来的类名，其实这不是重点。重点是`ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags)`。这就是生成`class`的地方，它把所有的条件组合好，生成`class`文件，然后再加载到内存里面以供使用。有兴趣的同学可以继续往深处查看。而我们需要做的是获取到他生成的字节码，看一下里面到底是什么？当`saveGeneratedFiles`为`true`的时候会保存`class`文件，所以我们在`DynamicProxyTest`的`main`函数添加一行即可：
</code></pre>

<p>System.setProperty(&ldquo;sun.misc.ProxyGenerator.saveGeneratedFiles&rdquo;, &ldquo;true&rdquo;);
<code>
通过`Debug`我们可以发现，它存储`class`文件的路径是`com/sun/proxy/$Proxy0.class`，所以直接在我们项目的目录下面就能找到它，然后通过`Idea`打开便得到如下代码：
</code>java $Proxy0.class
public final class $Proxy0 extends Proxy implements User {
    private static Method m1;
    private static Method m2;
    private static Method m3;
    private static Method m0;</p>

<pre><code>public $Proxy0(InvocationHandler var1) throws  {
    super(var1);
}

public final boolean equals(Object var1) throws  {
    try {
        return ((Boolean)super.h.invoke(this, m1, new Object[]{var1})).booleanValue();
    } catch (RuntimeException | Error var3) {
        throw var3;
    } catch (Throwable var4) {
        throw new UndeclaredThrowableException(var4);
    }
}

public final String toString() throws  {
    try {
        return (String)super.h.invoke(this, m2, (Object[])null);
    } catch (RuntimeException | Error var2) {
        throw var2;
    } catch (Throwable var3) {
        throw new UndeclaredThrowableException(var3);
    }
}

public final void create() throws  {
    try {
        super.h.invoke(this, m3, (Object[])null);
    } catch (RuntimeException | Error var2) {
        throw var2;
    } catch (Throwable var3) {
        throw new UndeclaredThrowableException(var3);
    }
}

public final int hashCode() throws  {
    try {
        return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();
    } catch (RuntimeException | Error var2) {
        throw var2;
    } catch (Throwable var3) {
        throw new UndeclaredThrowableException(var3);
    }
}

static {
    try {
        m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[]{Class.forName("java.lang.Object")});
        m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]);
        m3 = Class.forName("local.dynimicproxy.User").getMethod("create", new Class[0]);
        m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);
    } catch (NoSuchMethodException var2) {
        throw new NoSuchMethodError(var2.getMessage());
    } catch (ClassNotFoundException var3) {
        throw new NoClassDefFoundError(var3.getMessage());
    }
}
</code></pre>

<p>}
<code>``
这样好多问题就迎刃而解。  
为什么</code>Java动态代理<code>必须是接口，因为生成的类要去实现这个接口。  
</code>invoke<code>方法的</code>proxy<code>是干嘛的，通过</code>super.h.invoke(this, m3, (Object[])null);<code>我们可以发现传递给</code>invoke<code>方法的就是</code>Proxy<code>本身。  
同时</code>Proxy<code>类也通过反射实现了</code>toString<code>,</code>equals<code>,和</code>hashcode<code>等方法。  
自此关于</code>Java动态代理<code>的讲解已经告段落，下面让我们简单看一下</code>Spring-mybatis<code>中关于</code>Java动态代理`的使用。</p>

<h2>Java动态代理在Spring-mybatis中的实现</h2>

<p>关于<code>Spring-mybatis</code>的实现我们得从<code>MapperScannerConfigurer</code>说起，首先<code>MapperScannerConfigurer</code>实现了<code>BeanDefinitionRegistryPostProcessor</code>接口。而<code>BeanDefinitionRegistryPostProcessor</code>依赖于<code>Spring</code>框架，简单的说<code>BeanDefinitionRegistryPostProcessor</code>使得我们可以将<code>BeanDefinition</code>添加到<code>BeanDefinitionRegistry</code>中，而<code>BeanDefinition</code>描述了一个Bean实例所拥有的实例、结构参数和参数值，简单点说拥有它就可以实例化<code>Bean</code>了。<code>BeanDefinitionRegistryPostProcessor</code>的<code>postProcessBeanDefinitionRegistry</code>方法在<code>Bean</code>被定义但还没被创建的时候执行，所以<code>Spring-mybatis</code>也是借助了这一点。需要想需要更深入的了解可以查看<code>Spring</code>的生命周期。
<code>java MapperScannerConfigurer.java片段
public class MapperScannerConfigurer implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware {
  /**
   * {@inheritDoc}
   *
   * @since 1.0.2
   */
  @Override
  public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
    scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));
  }
</code>
由上代码我们可以看到在<code>postProcessBeanDefinitionRegistry</code>里面得到<code>registry</code>然后使用<code>ClassPathMapperScanner</code>开始扫描包路径得到的<code>Bean</code>并且注册到<code>registry</code>里面。我们接着往里面看。
&#8220;`java ClassPathMapperScanner.java
@Override
public Set<BeanDefinitionHolder> doScan(String&hellip; basePackages) {
Set<BeanDefinitionHolder> beanDefinitions = super.doScan(basePackages);</p>

<p>if (beanDefinitions.isEmpty()) {
  logger.warn(&ldquo;No MyBatis mapper was found in &lsquo;&rdquo; + Arrays.toString(basePackages) + &ldquo;&rsquo; package. Please check your configuration.&rdquo;);
} else {
  processBeanDefinitions(beanDefinitions);
}</p>

<p>return beanDefinitions;
}
<code>
`ClassPathMapperScanner`继承了`Spring`的`ClassPathBeanDefinitionScanner`所以调用父类的`doScan`方法就可以加载`Bean`然后再通过`processBeanDefinitions`方法加工成`MyBatis`需要的`Bean`。
</code>java ClassPathMapperScanner.java片段
private void processBeanDefinitions(Set<BeanDefinitionHolder> beanDefinitions) {
    GenericBeanDefinition definition;
    for (BeanDefinitionHolder holder : beanDefinitions) {
      definition = (GenericBeanDefinition) holder.getBeanDefinition();
      definition.setBeanClass(this.mapperFactoryBean.getClass());
    }
  }
<code>
如上代码循环了所有由`Spring`容器解析出来的`beanDefinitions`然后把他们的`BeanClass`修改为`mapperFactoryBean`，这就进入了行文的重点。我们翻看到`MapperFactoryBean`:
</code>java MapperFactoryBean.java片段
@Override
protected void checkDaoConfig() {
super.checkDaoConfig();</p>

<p>notNull(this.mapperInterface, &ldquo;Property &lsquo;mapperInterface&rsquo; is required&rdquo;);</p>

<p>Configuration configuration = getSqlSession().getConfiguration();
if (this.addToConfig &amp;&amp; !configuration.hasMapper(this.mapperInterface)) {
  try {
    configuration.addMapper(this.mapperInterface);
  } catch (Exception e) {
    logger.error(&ldquo;Error while adding the mapper &lsquo;&rdquo; + this.mapperInterface + &ldquo;&rsquo; to configuration.&rdquo;, e);
    throw new IllegalArgumentException(e);
  } finally {
    ErrorContext.instance().reset();
  }
}
}
<code>
其调用了`Configuration`的`addMapper`方法，这样就把`Bean`交给`MyBatis`管理了。那么`checkDaoConfig`是什么时候调用的呢？我们翻看其父类`DaoSupport`可以看到:
</code>java DaoSupport.java片段
public abstract class DaoSupport implements InitializingBean {
    @Override
  public final void afterPropertiesSet() throws IllegalArgumentException, BeanInitializationException {
    checkDaoConfig();
  }
}
<code>
因为`DaoSupport`实现了`InitializingBean`并重写`afterPropertiesSet`方法，了解`Spring`生命周期的同学知道`afterPropertiesSet`方法会在资源加载完以后，初始化bean之前执行。我们继续查看`addMapper`方法。
</code>java MapperRegistry.java片段
public <T> void addMapper(Class<T> type) {
    if (type.isInterface()) {
      if (hasMapper(type)) {
        throw new BindingException(&ldquo;Type &rdquo; + type + &ldquo; is already known to the MapperRegistry.&rdquo;);
      }
      boolean loadCompleted = false;
      try {
        knownMappers.put(type, new MapperProxyFactory<T>(type));
        // It&rsquo;s important that the type is added before the parser is run
        // otherwise the binding may automatically be attempted by the
        // mapper parser. If the type is already known, it won&rsquo;t try.
        MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
        parser.parse();
        loadCompleted = true;
      } finally {
        if (!loadCompleted) {
          knownMappers.remove(type);
        }
      }
    }
}
<code>
`addMapper`方法最终创建了`MapperProxyFactory`对象，在`MapperProxyFactory`里面我们两眼泪汪汪地发现了似曾相识的代码：
</code>java MapperProxyFactory.java片段
protected T newInstance(MapperProxy<T> mapperProxy) {
    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);
}</p>

<p>public T newInstance(SqlSession sqlSession) {
    final MapperProxy<T> mapperProxy = new MapperProxy<T>(sqlSession, mapperInterface, methodCache);
    return newInstance(mapperProxy);
}
<code>
而`MapperProxy`实现了`InvocationHandler`方法，最终实现对`Bean`的代理，同时获取到上下文的`sqlSession`以供使用。具体生成过程我们不再累述，直接通过其源码结束本篇文章：
</code>java MapperProxy.java片段
public class MapperProxy<T> implements InvocationHandler, Serializable {</p>

<p>  private static final long serialVersionUID = -6424540398559729838L;
  private final SqlSession sqlSession;
  private final Class<T> mapperInterface;
  private final Map&lt;Method, MapperMethod> methodCache;</p>

<p>  public MapperProxy(SqlSession sqlSession, Class<T> mapperInterface, Map&lt;Method, MapperMethod> methodCache) {
    this.sqlSession = sqlSession;
    this.mapperInterface = mapperInterface;
    this.methodCache = methodCache;
  }</p>

<p>  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    try {
      if (Object.class.equals(method.getDeclaringClass())) {
        return method.invoke(this, args);
      } else if (isDefaultMethod(method)) {
        return invokeDefaultMethod(proxy, method, args);
      }
    } catch (Throwable t) {
      throw ExceptionUtil.unwrapThrowable(t);
    }
    final MapperMethod mapperMethod = cachedMapperMethod(method);
    return mapperMethod.execute(sqlSession, args);
  }
}
&#8220;`</p>

<h2>参考链接</h2>

<p><a href="http://www.mybatis.org/spring/getting-started.html">Spring Mybatis 配置</a>  <br/>
<a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/">Spring Boot Mybatis</a><br/>
<a href="https://stackoverflow.com/questions/22930195/understanding-proxy-arguments-of-the-invoke-method-of-java-lang-reflect-invoca">InvocationHandler Proxy Parameter</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Idea 创建 Spring Boot 项目]]></title>
    <link href="http://www.majiang.life/blog/spring-boot-get-started/"/>
    <updated>2017-06-22T22:22:14+08:00</updated>
    <id>http://www.majiang.life/blog/spring-boot-get-started</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>最近 <code>Spring Boot</code> 如火如荼，于是也开始试试，不过上手真的太简单了。<code>Idea</code>非常方便的就可以创建，或者直接<code>clone</code>官方的例子<a href="https://spring.io/guides/gs/spring-boot/">https://spring.io/guides/gs/spring-boot/</a>。通俗理解<code>Spring Boot</code>就是一个<code>平台</code>，让你非常便捷的构建和运行一个项目，并且他是基于组件化的，你想用什么直接<code>拿来主义</code>就可以了，话不多少直接上手。</p>

<!-- more -->


<h2>使用 <code>Idea</code> 快速搭建</h2>

<p>选择<code>Spring Initialiar</code>直接创建。
<img src="/images/posts/spring-boot-get-started-1.png" alt="spring-boot-get-started-1" /></p>

<p>填写好<code>Group</code>和<code>Artifact</code>。
<img src="/images/posts/spring-boot-get-started-2.png" alt="spring-boot-get-started-2" /></p>

<p>下面直接选择<code>Web</code>就可以了，但是如果你想选择其他的直接勾选就行，她会自动为你加载依赖。并且一些<code>dependency</code>不需要配置版本，每一个<code>Spring Boot</code>的<code>parent</code>项目集成管理，这样省去了好多兼容麻烦。
<img src="/images/posts/spring-boot-get-started-3.png" alt="spring-boot-get-started-3" /></p>

<p>我们写一个<code>HelloController</code>试一下效果。
<img src="/images/posts/spring-boot-get-started-4.png" alt="spring-boot-get-started-4" /></p>

<p>最后访问<code>http://localhost:8080</code>成功。
<img src="/images/posts/spring-boot-get-started-5.png" alt="spring-boot-get-started-5" /></p>

<p>如果想改变端口也是非常简单的。
<img src="/images/posts/spring-boot-get-started-6.png" alt="spring-boot-get-started-6" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安全的使用Maven实现不同环境配置文件的部署]]></title>
    <link href="http://www.majiang.life/blog/using-maven-for-multiple-environment/"/>
    <updated>2017-04-15T19:30:35+08:00</updated>
    <id>http://www.majiang.life/blog/using-maven-for-multiple-environment</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>每一个项目都有许多部署环境，诸如开发环境，测试环境，沙盒环境，线上环境，有的项目还会更多。每一个环境都有自己独有的配置文件，比如数据库连接地址，静态资源的访问地址等等。那么如何优雅的分离这些配置文件是首要任务。目前已有的技术可以轻松的搞定这件事情，比如 Spring 的 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html">Profile</a>，Maven 的 <a href="http://maven.apache.org/guides/introduction/introduction-to-profiles.html">Profile</a>，但是有的时候我们为了方便，直接把这些配置文件都放在了<code>Project</code>里面，这样增加了项目的风险，也不便于管理。那么接下来我们就想来一个优雅的方法使用 <code>Maven Profile</code> 安全分离配置文件。</p>

<!-- more -->


<h2>Filter</h2>

<p><code>Maven Filter</code>可以支持将写到 <code>settings.xml</code>, <code>pom.xml</code>, 或是自定义 <code>*.properties</code> 文件里面的 <code>properties</code> 在 <code>build</code> 的时候自动替换指定目录配置文件里面的<code>占位符</code>，以实现动态指定配置。基本配置如下： <br/>
我们在<code>resources</code> 目录有一配置文件 <code>src/main/resources/config.properties</code> 包含如下内容(<em>如果使用<code>Spring-boot</code>需要把 <code>${username}</code> 替换为 <code>@username@</code></em>)  <br/>
<code>properties src/main/resources/config.properties
GitHub : ${username}
</code>
POM文件如下，用来指定资源的存放路径和是否使用<code>filter</code>：
&#8220;`xml ${project}/pom.xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion></p>

<pre><code>&lt;groupId&gt;com.github.codedrinker&lt;/groupId&gt;
&lt;artifactId&gt;maven-env-deploy&lt;/artifactId&gt;
&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

&lt;name&gt;My Resources Plugin Practice Project&lt;/name&gt;

&lt;properties&gt;
    &lt;username&gt;codedrinker&lt;/username&gt;
&lt;/properties&gt;
&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;filtering&gt;true&lt;/filtering&gt;&lt;!--至关重要--&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>

<p></project>
<code>
运行命令
</code>sh
mvn resources:resources</p>

<h1>这里同样可以使用 mvn clean compile，只是resources不会编译代码，只会构建资源文件，这样更方便我们调试</h1>

<pre><code>在 `target/classes/config.properties` 查看文件内容，已经变化了。
</code></pre>

<p>GitHub : codedrinker
&#8220;`</p>

<h2>Profile</h2>

<p><code>Profile</code> 可以让我们根据不同的环境，定义不同的 <code>properties</code>。配置如下：
&#8220;`xml ${project}/pom.xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.github.codedrinker</groupId>
    <artifactId>maven-env-deploy</artifactId>
    <version>1.0-SNAPSHOT</version></p>

<pre><code>&lt;name&gt;My Resources Plugin Practice Project&lt;/name&gt;

&lt;profiles&gt;
    &lt;profile&gt;
        &lt;id&gt;sandbox&lt;/id&gt;
        &lt;properties&gt;
            &lt;username&gt;codedrinker&lt;/username&gt;
        &lt;/properties&gt;
    &lt;/profile&gt;
    &lt;profile&gt;
        &lt;id&gt;dev&lt;/id&gt;
        &lt;properties&gt;
            &lt;username&gt;majiang&lt;/username&gt;
        &lt;/properties&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;filtering&gt;true&lt;/filtering&gt;&lt;!--至关重要--&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>

<p></project>
<code>
运行
</code>sh
mvn resources:resources -P sandbox
<code>
结果如下
</code>
GitHub : codedrinker
<code>
运行
</code>
mvn resources:resources -P dev
<code>
结果如下
</code>
GitHub : majiang
<code>``
这样就实现了在不同环境部署不同的配置文件了。但是接下来问题来了，这样如果我们存储了用户名密码等信息，也会随着项目一起提交。这时候</code>Maven<code>的</code>settings.xml` 就派上用场了。</p>

<h2>Settings.xml</h2>

<p>正好 <code>settings.xml</code> 可以包含<code>profiles</code>，那么我们直接把对应的配置放进来不就可以了吗？有两个地方包含<code>settings.xml</code>：</p>

<ul>
<li>Maven的安装目录 <code>${maven.home}/conf/settings.xml</code></li>
<li>用户的目录 <code>${user.home}/.m2/settings.xml</code></li>
</ul>


<p>前者是全局的设置，后者是用户的设置，官方文档中指出如果两个都有设置，会以用户为主进行合并。但是我并不清楚它的合并力度，于是做了如下实验</p>

<p>系统配置
<code>xml ${maven.home}/conf/settings.xml
    &lt;!-- 系统配置 --&gt;
    &lt;profile&gt;
        &lt;id&gt;sandbox&lt;/id&gt;
        &lt;properties&gt;
            &lt;username&gt;majiang&lt;/username&gt;
            &lt;password&gt;majiang&lt;/password&gt;
            &lt;website&gt;http://www.majiang.life&lt;/website&gt;
        &lt;/properties&gt;
    &lt;/profile&gt;
</code>
用户配置
<code>xml ${user.home}/.m2/settings.xml
    &lt;!-- 用户配置 --&gt;
    &lt;profile&gt;
            &lt;id&gt;sandbox&lt;/id&gt;
            &lt;properties&gt;
                &lt;username&gt;codedrinker&lt;/username&gt;
                &lt;password&gt;codedrinker&lt;/password&gt;
            &lt;/properties&gt;
    &lt;/profile&gt;
</code>
config.properties
<code>properties src/main/resources/config.properties
username : ${username}
password : ${password}
website : ${website}
</code>
再次运行命令以后的结果
<code>properties target/classes/config.properties
username : codedrinker
password : password
website : ${website}
</code>
令人奇怪的事情发生了，编译的结果确实以<code>用户级settings.xml</code>为准，但是<code>系统级settings.xml</code>里面额外配置的<code>website</code>并没有编译。于是我就带着这个疑问看了一下Maven的源码：
本身 <code>Maven</code> 定义了一个 <code>Profile</code> 类用来映射每一个<code>profile</code>，该类有一个<code>properties</code>属性，用来存放当前<code>profile</code>的配置：
<code>java
    /**
     * Field properties.
     */
    private java.util.Properties properties;
</code>
在读取配置文件的时候，直接读取<code>properties</code>，没有其他处理
<code>java SettingsXpp3Reader.java
else if ( checkFieldWithDuplicate( parser, "properties", null, parsed ) )
            {
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    String key = parser.getName();
                    String value = parser.nextText().trim();
                    profile.addProperty( key, value );
                }
            }
</code>
关键在于<code>以用户的settings为主，合并配置的逻辑</code>，他的逻辑是如果<code>profile.id</code>不相同才会合并到<code>用户级别的settings</code>，不会深度的比较。于是这个问题是无解的，他所说的<code>以用户级settings.xml</code>为主指的是每一个配置，里面的每一个<code>property</code>是不被合并的。
&#8220;`java MavenSettingsMerger.java
private static <T extends IdentifiableBase> void shallowMergeById( List<T> dominant, List<T> recessive,
                                                                       String recessiveSourceLevel )
    {
        Map&lt;String, T> dominantById = mapById( dominant );</p>

<pre><code>    for ( T identifiable : recessive )
    {
        if ( !dominantById.containsKey( identifiable.getId() ) )
        {
            identifiable.setSourceLevel( recessiveSourceLevel );

            dominant.add( identifiable );
        }
    }
}
</code></pre>

<p><code>``
所以我们想同时使用系统和用户级别的</code>settings`的时候，需要格外注意这一点。</p>

<h2>POM.xml</h2>

<p>文档中并没有明确说明项目中的<code>pom.xml</code>文件和<code>系统</code>，<code>用户</code>级别的<code>settings.xml</code>的优先级，但是经测试写在项目里面的配置文件，会直接编译到指定的<code>config.properties</code>里面，并且他会把独有的属性也编译到文件。</p>

<h2>总结</h2>

<p>所以最终的结果</p>

<ul>
<li>非安全性的配置文件，直接配置到项目的<code>pom.xml</code>里面。</li>
<li>安全性质的配置文件，配置到<code>用户级别的settings.xml</code>。</li>
<li><code>系统级别的settings.xml</code>做一些系统级别的配置，不轻易使用，和用户区分开来。</li>
</ul>


<h2>参考链接</h2>

<p><a href="https://maven.apache.org/plugins/maven-resources-plugin/examples/filter.html">Filter</a><br/>
<a href="http://maven.apache.org/guides/introduction/introduction-to-profiles.html">Profile</a><br/>
<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto-properties-and-configuration.html">howto-properties-and-configuration</a> <br/>
<a href="https://maven.apache.org/settings.html">Settings.xml</a></p>
]]></content>
  </entry>
  
</feed>
