<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Octopress | 码匠笔记]]></title>
  <link href="http://www.majiang.life/blog/categories/octopress/atom.xml" rel="self"/>
  <link href="http://www.majiang.life/"/>
  <updated>2018-02-23T11:46:09+08:00</updated>
  <id>http://www.majiang.life/</id>
  <author>
    <name><![CDATA[麻酱]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Commenthub —— 多说、网易云跟帖的替代品]]></title>
    <link href="http://www.majiang.life/blog/octopress-and-hexo-comments-widget/"/>
    <updated>2018-02-19T20:57:35+08:00</updated>
    <id>http://www.majiang.life/blog/octopress-and-hexo-comments-widget</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>“多说”和“网易云跟帖”相继不维护了，每一次给大家带来了希望又带来了失望，于是 <a href="https://github.com/codedrinker/commenthub">Commenthub</a> 出现了。Commenthub 是作者使用免费的服务 Heroku 和 Github Issues 结合起来做的一套开源的评论系统。其灵感源于 Gitment，但是 Gitment 的 Key 和 Secret 都存在浏览器端，这样对于安全也是一个问题，于是作者使用 Heroku 搭建后端服务用于处理业务和存储证书，通过 iframe 实现评论功能。</p>

<!-- more -->


<h2>效果图</h2>

<p><img src="/images/posts/commenthub1.png" alt="Demo" /></p>

<h2>演示地址</h2>

<p><a href="http://commenthub.github.io/">http://commenthub.github.io/</a></p>

<h2>功能介绍</h2>

<p>Commenthub 目前只支持 Github 用户登录评论，同时也只支持 Github 用户为自己的博客添加评论功能。目前 Commenthub 支持 Markdown 语法，表情，手机和PC响应式布局。</p>

<h2>Octopress 接入</h2>

<h3>注册 commenthub 账号</h3>

<p>访问 <a href="http://commenthub.herokuapp.com/">Commenthub官网</a>，点击 Sign up，使用 Github 账号登录成功以后，点击 Set up，填写博客地址。同时记住 ID，后面需要使用。</p>

<h3>配置 config.yml</h3>

<p>在 config.yml 里面填写 commenthub_id，其内容就是上面说的ID，用于标记作者是谁。
<code>
commenthub_id: 3821949
</code></p>

<h3>配置显示位置</h3>

<p>在 <code>_layouts/post.html</code> 的 article 标签下面添加如下代码，用来告诉 Commenthub，在什么地方显示评论功能。
{% codeblock lang:html %}
{% raw %}
{% if site.commenthub_id and page.comments == true %}
  <section>
    <h1>评论</h1>
    <div id="commenthub_thread" aria-live="polite"></div>
  </section>
{% endif %}
{% endraw %}
{% endcodeblock %}</p>

<h3>创建 commenthub.html</h3>

<p>创建 <code>includes/commenthub.html</code>，填入如下内容
{% codeblock lang:html %}
{% raw %}
{% comment %} Load script if commenthub comments are enabled and <code>page.comments</code> is either empty (index) or set to true {% endcomment %}
{% if site.commenthub_id and page.comments != false %}</p>

<script type="text/javascript">
    var commenthub_id = '{{ site.commenthub_id }}';
    var commenthub_website = '{{ site.url }}';
    var commenthub_identifier = '{{ page.url }}';
    var commenthub_url = '{{ site.url }}{{ page.url }}';
    var commenthub_title = '{{ page.title }}';
    (function () {
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = 'https://commenthub.herokuapp.com/js/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>


<p>{% endif %}
{% endraw %}
{% endcodeblock %}</p>

<h3>引入 commenthub.html</h3>

<p>在 <code>includes/after_foot.html</code> 里面添加一行如下内容，用于引入 commenthub.html 文件
{% codeblock lang:html %}
{% raw %}
{% include commenthub.html %}
{% endraw %}
{% endcodeblock %}</p>

<h3>完成</h3>

<p>这样 Octopress 的配置就结束了，如果配置中遇到问题，可以在当前博客中评论留言，或者到 Github Issue 中留言。</p>

<h2>Hexo 接入</h2>

<p>Hexo 使用的是比较热门的主题 Next。</p>

<h3>注册 commenthub 账号</h3>

<p>同上</p>

<h3>配置 config.yml</h3>

<p>配置 <code>themes/next/_config.yml</code> 文件，在里面的 Disqus 后面配置如下内容
<code>
commenthub:
  enable: true
  id: your_id
  site: your_website_url
</code></p>

<h3>配置显示位置</h3>

<p>在<code>themes/next/layout/_partials/comments.swig</code>里面添加一行代码，记得注意看<code>elseif</code>的位置
{% codeblock lang:html %}
{% raw %}
  {% elseif theme.commenthub.enable %}
    <div class="comments" id="comments">
      <div id="commenthub_thread"></div>
    </div>
{% endraw %}
{% endcodeblock %}</p>

<h3>创建 commenthub.swig</h3>

<p>创建新文件<code>themes/next/layout/_third-party/comments/commenthub.swig</code>并贴入如下代码，如下代码主要是用于加载和生成评论的逻辑。
{% codeblock lang:html %}
{% raw %}
{% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname %}
  {% if theme.commenthub.enable %}
      <script type="text/javascript">
        var commenthub_id = &lsquo;{{ theme.commenthub.id }}&rsquo;;
        var commenthub_website = &lsquo;{{ theme.commenthub.site }}&rsquo;;
        var commenthub_identifier = &lsquo;{{ page.path }}&rsquo;;
        var commenthub_url = &lsquo;{{ page.permalink }}&rsquo;;
        var commenthub_title = &lsquo;{{ page.title| addslashes }}&rsquo;;
        var dsq = document.createElement(&lsquo;script&rsquo;);
            dsq.type = &lsquo;text/javascript&rsquo;;
            dsq.async = true;
            dsq.src = &lsquo;<a href="https://commenthub.herokuapp.com/js/embed.js">https://commenthub.herokuapp.com/js/embed.js</a>&rsquo;;
            (document.getElementsByTagName(&lsquo;head&rsquo;)[0] || document.getElementsByTagName(&lsquo;body&rsquo;)[0]).appendChild(dsq);
      </script>
  {% endif %}
{% endif %}
{% endraw %}
{% endcodeblock %}</p>

<h3>引入 commenthub.swig</h3>

<p>在<code>themes/next/layout/_third-party/comments/index.swig</code>文件添加如下代码：
{% codeblock lang:html %}
{% raw %}
{% include &lsquo;commenthub.swig&rsquo; %}</p>

<p>{% endraw %}
{% endcodeblock %}</p>

<h3>完成</h3>

<p>这样 Hexo 的配置就结束了，如果配置中遇到问题，可以在当前博客中评论留言，或者到 Github Issue 中留言。</p>

<h2>建议与反馈</h2>

<p>如果在使用过程中有任何问题欢迎建议和反馈到 <a href="https://github.com/codedrinker/commenthub">Commenthub</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给博客添加目录]]></title>
    <link href="http://www.majiang.life/blog/blog-table-of-contents/"/>
    <updated>2018-02-19T12:11:10+08:00</updated>
    <id>http://www.majiang.life/blog/blog-table-of-contents</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>Hexo 模板的博客都带了文章目录[toc]，但是作者当前使用的是 Octopress 博客系统，所以不支持目录。这样给阅读的人带来了很大的不便捷。所以作者使用了 Table of contents sidebar 为 Octopress 添加了目录，并且可以快速定位。过程很简单，内容如下。</p>

<!-- more -->


<h2>添加插件</h2>

<p>直接添加到如下代码到博客通用的文件即可，其中 querySelector 可以定义生成目录的区域。
{% codeblock lang:html %}
{% raw %}</p>

<script type="text/javascript" src="https://table-of-contents-sidebar.github.io/table-of-contents-sidebar-lib/table-of-contents-sidebar.js"></script>


<script type="text/javascript">
    window.onload = function(e){ 
        TableOfContents.init({
            basePath: "https://table-of-contents-sidebar.github.io/table-of-contents-sidebar-lib/",
            querySelector: "body" // or other css querySelector
        });
    }
</script>


<p>{% endraw %}
{% endcodeblock %}</p>

<h2>插件</h2>

<p>这样仅仅是看自己的博客有了目录，如果想看别人的博客也有目录，可以安装 Table of contents sidebar 的插件，这样只要能识别的文章都能查看目录并且快速定位了。<br/>
<a href="https://chrome.google.com/webstore/detail/table-of-contents-sidebar/ohohkfheangmbedkgechjkmbepeikkej">https://chrome.google.com/webstore/detail/table-of-contents-sidebar/ohohkfheangmbedkgechjkmbepeikkej</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为 Octopress 添加 扩展相关阅读]]></title>
    <link href="http://www.majiang.life/blog/octopress-related-posts/"/>
    <updated>2018-02-18T20:24:22+08:00</updated>
    <id>http://www.majiang.life/blog/octopress-related-posts</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>原生的 Octopress 没有更丰富的阅读体验，只有上一篇下一篇，每次需要为当前文章添加相关文章的时候都需要在 Markdown 里面手动填写，这样非常浪费时间又不全面，于是笔者使用 Category 作为相关性的依据，修改了 Liqiud 代码，使得每一个 post 里面有具有相关的文章。</p>

<!-- more -->


<h2>实现</h2>

<p>实现起来也是很简单的，直接把如下代码添加到 <code>includes/article.html</code> 里面，跟在下面代码之后即可。
{% codeblock lang:html %}
{% raw %}</p>

<p><div class="entry-content">{{ content }}
{% endraw %}
{% endcodeblock %}<br/>
代码如下
{% codeblock lang:html %}
{% raw %}
<h2>扩展阅读</h2>
{% if page %}
    <ol>
      {% for category in page.categories %}
        {% for post in site.categories[category] %}
        {% if  page.url == post.url %}
          {% continue %}
        {% endif %}
        <li>
          <a href="{{ root_url }}{{ post.url }}">{% if site.titlecase %}{{ post.title | titlecase }}{% else %}{{ post.title }}{% endif %}</a>
        </li>
        {% endfor %}
      {% endfor %}
    </ol>
{% endif %}
{% endraw %}
{% endcodeblock %}
原理就比较简单了，取到当前页面的 categories，然后循环遍历得到每一个category下面的 post 展示即可。</p>

<h2>参照</h2>

<p>实际中的应用可以参照如下地址<br/>
<a href="https://github.com/codedrinker/codedrinker.github.io/blob/source/source/_includes/article.html">参考地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress 添加标签云]]></title>
    <link href="http://www.majiang.life/blog/octopress-tag-cloud/"/>
    <updated>2017-06-24T15:11:51+08:00</updated>
    <id>http://www.majiang.life/blog/octopress-tag-cloud</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>随着文章数量越来越多，分类也越来越多，不是很方便归类和查找，于是就有了<code>标签云</code>这个概念。简单明了的展示了标签和每一个标签下面的文章数量。这个功能可以自己编写，也非常简单。不过反正已经有轮子了，如果不喜欢重新造轮子，直接使用一个网上已经写好的就行了。下面直接进入正题：</p>

<h2>使用轮子</h2>

<p>直接<code>clone</code>轮子<code>https://github.com/tokkonopapa/octopress-tagcloud.git</code>到本地，如果不想<code>clone</code>直接点击<a href="/assets/octopress-tagcloud-master.zip">下载</a>，然后把对应的资源拷贝到相应的目录：</p>

<!-- more -->


<pre><code>.
├─ plugins/
│  └── tag_cloud.rb
└─ source/
   └─ _includes/
      └─ custom/
         └─ asides/
            ├─ category_list.html
            └─ tag_cloud.html
</code></pre>

<p>然后修改 <code>_config.yml</code>，添加 <code>tag_cloud.html</code> 到 <code>default_asides</code> 数组，重新<code>rake preview</code>即可。</p>

<h2>造轮子</h2>

<p>造轮子原理也是很简单，遍历所有的<code>category</code>和每一个<code>category</code>下面的<code>posts</code>，然后编写好样式做输出就可以了。<code>plugins</code>这个目录用户存放一些<code>Ruby</code>的<code>plugins</code>文件，所以我们直接写一个脚本到这个目录:
{% codeblock lang:ruby plugins/tag_cloud.rb%}
{% raw %}</p>

<h1>plugins/tag_cloud.rb</h1>

<p>module Jekyll<br/>
  class CategoryListTag &lt; Liquid::Tag<br/>
    def render(context)<br/>
      html = &ldquo;&rdquo;<br/>
      categories = context.registers[:site].categories.keys<br/>
      categories.sort.each do |category|<br/>
        posts_in_category = context.registers[:site].categories[category].size<br/>
        category_dir = context.registers[:site].config[&lsquo;category_dir&rsquo;]<br/>
        category_url = File.join(category_dir, category.gsub(/_|\P{Word}/, &lsquo;-&rsquo;).gsub(/-{2,}/, &lsquo;-&rsquo;).downcase)<br/>
        html &lt;&lt; &ldquo;<li class='category'><a href='http://www.majiang.life/#{category_url}/'>#{category} (#{posts_in_category})</a></li>\n&rdquo;<br/>
      end<br/>
      html<br/>
    end<br/>
  end<br/>
end</p>

<p>Liquid::Template.register_tag(&lsquo;tag_cloud&rsquo;, Jekyll::CategoryListTag)
{% endraw %}
{% endcodeblock %}</p>

<p>{% codeblock lang:html source/_includes/custom/asides/tag_cloud.html%}
{% raw %}</p>

<!-- source/_includes/custom/asides/tag_cloud.html-->


<p><section><br/>
  <h1>Categories</h1><br/>
  <ul id="categories"><br/>
    {% tag_cloud %}<br/>
  </ul><br/>
</section>
{% endraw %}
{% endcodeblock %}</p>

<p>{% codeblock lang:yml _.config.yml%}
{% raw %}</p>

<h1>_config.yml</h1>

<p>default_asides: [&hellip;,custom/asides/tag_cloud.html]<br/>
{% endraw %}
{% endcodeblock %}</p>

<p>下面我们逐行解释： <br/>
<code>context</code>会传递传递静态博客需要的上下文,<code>category</code>和<code>posts</code>都可以在里面获取。<br/>
<code>Liquid::Template.register_tag</code> 最后生成<code>tag_cloud</code>标签，以便在<code>html</code>里面可以直接使用。<br/>
<code>tag_cloud.html</code> 直接在<code>html</code>里面使用<code>tag_cloud</code>标签<br/>
<code>_config.yml</code> 最后再里面配置就可以了</p>

<p>笔者前端不是很好，如果想把轮子造的好看一点，直接自定义<code>tag_cloud.rb</code>里面的<code>html</code>样式即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为Octopress 首页添加‘更多’功能]]></title>
    <link href="http://www.majiang.life/blog/octopress-index-page-read-more/"/>
    <updated>2017-06-24T14:32:31+08:00</updated>
    <id>http://www.majiang.life/blog/octopress-index-page-read-more</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>在使用 <code>Octopress</code> 的过程中随着文章数量的增加，首页越来越臃肿，不仅加载慢而且可读性很差。看到过其他人的 <code>Octopress</code> 首页很简洁，有一个 <code>Read more</code>，这样就非常方便了。查询了一下操作起来也非常简单。</p>

<h2>添加更多</h2>

<p>方法是十分的简单，只是因为不是太熟悉<code>Octopress</code>导致查了很久。直接在 <code>*.markdown</code> 的 <code>post</code> 里面添加<code>&lt;!--more--&gt;</code>，这个标记下面的内容就不会在首页展示出来，并且通过一个<code>Read on</code>替换。原因是因为本身<code>Octopress</code>就支持，只是你没有使用。具体在<code>_config.yml</code>里面。
<code>yml _.config.yml
//_.config.yml
excerpt_link: "Read on &amp;rarr;"  # "Continue reading" link text at the bottom of excerpted articles
excerpt_separator: "&lt;!--more--&gt;"
</code>
如果想修改<code>Read on</code>直接在<code>_config.yml</code>里面修改就可以了。</p>
]]></content>
  </entry>
  
</feed>
